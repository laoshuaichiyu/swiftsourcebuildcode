#line 6 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
//// Automatically Generated From ParsedSyntaxRecorder.cpp.gyb.
//// Do Not Edit Directly!
//===--- ParsedSyntaxRecorder.cpp - Parsed Syntax Recorder ----------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

#include "swift/Parse/ParsedSyntaxRecorder.h"
#include "swift/Parse/ParsedRawSyntaxRecorder.h"
#include "swift/Parse/SyntaxParsingContext.h"
#include "swift/Syntax/SyntaxFactory.h"

using namespace swift;
using namespace swift::syntax;

bool ParsedSyntaxRecorder::formExactLayoutFor(syntax::SyntaxKind Kind,
        ArrayRef<ParsedRawSyntaxNode> Elements,
        function_ref<void(syntax::SyntaxKind, ArrayRef<ParsedRawSyntaxNode>)> receiver) {
  switch (Kind) {
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::Decl: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::Expr: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::Stmt: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::Type: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::Pattern: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::UnknownDecl: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::UnknownExpr: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::UnknownStmt: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::UnknownType: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::UnknownPattern: {
#line 64 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    return false;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CodeBlockItem: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Item
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Item
return [](const ParsedRawSyntaxNode &Raw) {
 // check Decl
return ParsedDeclSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Stmt
return ParsedStmtSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Expr
return ParsedExprSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check TokenList
return ParsedTokenListSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check NonEmptyTokenList
return ParsedNonEmptyTokenListSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Semicolon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Semicolon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::semi;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ErrorTokens
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ErrorTokens
return ParsedSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CodeBlockItemList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::CodeBlockItemList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CodeBlock: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Statements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Statements
return ParsedCodeBlockItemListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::InOutExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Ampersand
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Ampersand
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::amp_prefix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundColumnExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundColumn
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundColumn
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_column;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FunctionCallArgumentList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::FunctionCallArgumentList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TupleElementList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::TupleElementList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ArrayElementList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::ArrayElementList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DictionaryElementList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::DictionaryElementList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::StringLiteralSegments: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::StringLiteralSegments, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TryExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] TryKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TryKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_try;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] QuestionOrExclamationMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check QuestionOrExclamationMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::question_postfix || TokKind == tok::exclaim_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DeclNameArgument: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
return ParsedTokenSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DeclNameArgumentList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::DeclNameArgumentList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DeclNameArguments: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Arguments
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Arguments
return ParsedDeclNameArgumentListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IdentifierExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier || TokKind == tok::kw_self || TokKind == tok::kw_Self || TokKind == tok::dollarident || TokKind == tok::oper_binary_spaced;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] DeclNameArguments
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DeclNameArguments
return ParsedDeclNameArgumentsSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SuperRefExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] SuperKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check SuperKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_super;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::NilLiteralExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] NilKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check NilKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_nil;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DiscardAssignmentExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Wildcard
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Wildcard
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw__;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AssignmentExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] AssignToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AssignToken
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::equal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SequenceExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Elements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Elements
return ParsedExprListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ExprList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::ExprList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundLineExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundLine
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundLine
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_line;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundFileExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundFile
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundFile
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_file;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundFunctionExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundFunction
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundFunction
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_function;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundDsohandleExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundDsohandle
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundDsohandle
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_dsohandle;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SymbolicReferenceExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] GenericArgumentClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericArgumentClause
return ParsedGenericArgumentClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PrefixOperatorExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] OperatorToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check OperatorToken
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::oper_prefix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] PostfixExpression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PostfixExpression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::BinaryOperatorExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] OperatorToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check OperatorToken
return ParsedTokenSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ArrowExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] ThrowsToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ThrowsToken
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_throws;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ArrowToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ArrowToken
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::arrow;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FloatLiteralExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] FloatingDigits
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check FloatingDigits
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::floating_literal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TupleExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ElementList
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ElementList
return ParsedTupleElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ArrayExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftSquare
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftSquare
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Elements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Elements
return ParsedArrayElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightSquare
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightSquare
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DictionaryExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftSquare
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftSquare
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Content
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Content
return [](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Elements
return ParsedDictionaryElementListSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightSquare
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightSquare
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FunctionCallArgument: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Label
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Label
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TupleElement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Label
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Label
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ArrayElement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DictionaryElement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] KeyExpression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check KeyExpression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ValueExpression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ValueExpression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IntegerLiteralExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Digits
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Digits
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::integer_literal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::BooleanLiteralExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] BooleanLiteral
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check BooleanLiteral
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_true || TokKind == tok::kw_false;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TernaryExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] ConditionExpression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ConditionExpression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] QuestionMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check QuestionMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::question_infix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] FirstChoice
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check FirstChoice
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] ColonMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ColonMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] SecondChoice
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check SecondChoice
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::MemberAccessExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Base
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Base
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Dot
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Dot
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::period || TokKind == tok::period_prefix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
return ParsedTokenSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] DeclNameArguments
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DeclNameArguments
return ParsedDeclNameArgumentsSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IsExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] IsTok
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check IsTok
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_is;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TypeName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypeName
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AsExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] AsTok
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AsTok
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_as;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] QuestionOrExclamationMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check QuestionOrExclamationMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::question_postfix || TokKind == tok::exclaim_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] TypeName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypeName
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TypeExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Type
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Type
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ClosureCaptureItem: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Specifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Specifier
return ParsedTokenListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] AssignToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AssignToken
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::equal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ClosureCaptureItemList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::ClosureCaptureItemList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ClosureCaptureSignature: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftSquare
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftSquare
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Items
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Items
return ParsedClosureCaptureItemListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightSquare
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightSquare
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ClosureParam: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier || TokKind == tok::kw__;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ClosureParamList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::ClosureParamList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ClosureSignature: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Capture
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Capture
return ParsedClosureCaptureSignatureSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Input
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Input
return [](const ParsedRawSyntaxNode &Raw) {
 // check SimpleInput
return ParsedClosureParamListSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Input
return ParsedParameterClauseSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ThrowsTok
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ThrowsTok
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_throws;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Output
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Output
return ParsedReturnClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] InTok
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InTok
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_in;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ClosureExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Signature
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Signature
return ParsedClosureSignatureSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Statements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Statements
return ParsedCodeBlockItemListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::UnresolvedPatternExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Pattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Pattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FunctionCallExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] CalledExpression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CalledExpression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ArgumentList
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ArgumentList
return ParsedFunctionCallArgumentListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] TrailingClosure
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingClosure
return ParsedClosureExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SubscriptExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] CalledExpression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CalledExpression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ArgumentList
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ArgumentList
return ParsedFunctionCallArgumentListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] TrailingClosure
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingClosure
return ParsedClosureExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::OptionalChainingExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] QuestionMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check QuestionMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::question_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ForcedValueExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ExclamationMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ExclamationMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::exclaim_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PostfixUnaryExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] OperatorToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check OperatorToken
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::oper_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SpecializeExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] GenericArgumentClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericArgumentClause
return ParsedGenericArgumentClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::StringSegment: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Content
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Content
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::string_segment;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ExpressionSegment: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Backslash
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Backslash
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::backslash;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Delimiter
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Delimiter
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::raw_string_delimiter;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Expressions
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expressions
return ParsedFunctionCallArgumentListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::string_interpolation_anchor;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::StringLiteralExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] OpenDelimiter
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check OpenDelimiter
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::raw_string_delimiter;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] OpenQuote
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check OpenQuote
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::string_quote || TokKind == tok::multiline_string_quote;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Segments
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Segments
return ParsedStringLiteralSegmentsSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] CloseQuote
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CloseQuote
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::string_quote || TokKind == tok::multiline_string_quote;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] CloseDelimiter
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CloseDelimiter
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::raw_string_delimiter;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::KeyPathExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Backslash
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Backslash
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::backslash;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] RootExpr
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RootExpr
return [](const ParsedRawSyntaxNode &Raw) {
 // check IdentifierExpr
return ParsedIdentifierExprSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check SpecializeExpr
return ParsedSpecializeExprSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::KeyPathBaseExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Period
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Period
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::period;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ObjcNamePiece: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Dot
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Dot
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::period;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ObjcName: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::ObjcName, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ObjcKeyPathExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] KeyPath
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check KeyPath
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_keyPath;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
return ParsedObjcNameSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ObjcSelectorExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[6];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundSelector
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundSelector
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_selector;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Kind
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Kind
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::contextual_keyword;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::EditorPlaceholderExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ObjectLiteralExpr: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_colorLiteral || TokKind == tok::pound_fileLiteral || TokKind == tok::pound_imageLiteral;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Arguments
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Arguments
return ParsedFunctionCallArgumentListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TypeInitializerClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Equal
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Equal
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::equal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Value
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Value
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TypealiasDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[7];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] TypealiasKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypealiasKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_typealias;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] GenericParameterClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericParameterClause
return ParsedGenericParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] Initializer
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Initializer
return ParsedTypeInitializerClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AssociatedtypeDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[7];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] AssociatedtypeKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AssociatedtypeKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_associatedtype;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] InheritanceClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InheritanceClause
return ParsedTypeInheritanceClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] Initializer
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Initializer
return ParsedTypeInitializerClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FunctionParameterList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::FunctionParameterList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ParameterClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ParameterList
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ParameterList
return ParsedFunctionParameterListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ReturnClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Arrow
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Arrow
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::arrow;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ReturnType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ReturnType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FunctionSignature: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Input
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Input
return ParsedParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ThrowsOrRethrowsKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ThrowsOrRethrowsKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_throws || TokKind == tok::kw_rethrows;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Output
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Output
return ParsedReturnClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IfConfigClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_if || TokKind == tok::pound_elseif || TokKind == tok::pound_else;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Condition
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Condition
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Elements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Elements
return [](const ParsedRawSyntaxNode &Raw) {
 // check Statements
return ParsedCodeBlockItemListSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check SwitchCases
return ParsedSwitchCaseListSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Decls
return ParsedMemberDeclListSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IfConfigClauseList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::IfConfigClauseList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IfConfigDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Clauses
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Clauses
return ParsedIfConfigClauseListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] PoundEndif
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundEndif
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_endif;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundErrorDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundError
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundError
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_error;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Message
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Message
return ParsedStringLiteralExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundWarningDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundWarning
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundWarning
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_warning;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Message
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Message
return ParsedStringLiteralExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundSourceLocation: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundSourceLocation
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundSourceLocation
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_sourceLocation;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Args
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Args
return ParsedPoundSourceLocationArgsSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundSourceLocationArgs: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[7];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] FileArgLabel
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check FileArgLabel
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] FileArgColon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check FileArgColon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] FileName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check FileName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::string_literal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Comma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Comma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] LineArgLabel
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LineArgLabel
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] LineArgColon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LineArgColon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] LineNumber
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LineNumber
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::integer_literal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DeclModifier: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
return Raw.isToken();
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] DetailLeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DetailLeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Detail
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Detail
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] DetailRightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DetailRightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::InheritedType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] TypeName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypeName
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::InheritedTypeList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::InheritedTypeList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TypeInheritanceClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] InheritedTypeCollection
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InheritedTypeCollection
return ParsedInheritedTypeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ClassDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[8];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ClassKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ClassKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_class;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] GenericParameterClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericParameterClause
return ParsedGenericParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] InheritanceClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InheritanceClause
return ParsedTypeInheritanceClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[7] Members
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Members
return ParsedMemberDeclBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[7] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::StructDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[8];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] StructKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check StructKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_struct;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] GenericParameterClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericParameterClause
return ParsedGenericParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] InheritanceClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InheritanceClause
return ParsedTypeInheritanceClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[7] Members
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Members
return ParsedMemberDeclBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[7] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ProtocolDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[7];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ProtocolKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ProtocolKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_protocol;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] InheritanceClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InheritanceClause
return ParsedTypeInheritanceClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] Members
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Members
return ParsedMemberDeclBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ExtensionDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[7];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ExtensionKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ExtensionKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_extension;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] ExtendedType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ExtendedType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] InheritanceClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InheritanceClause
return ParsedTypeInheritanceClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] Members
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Members
return ParsedMemberDeclBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::MemberDeclBlock: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Members
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Members
return ParsedMemberDeclListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::MemberDeclList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::MemberDeclList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::MemberDeclListItem: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Decl
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Decl
return ParsedDeclSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Semicolon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Semicolon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::semi;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SourceFile: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Statements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Statements
return ParsedCodeBlockItemListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] EOFToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check EOFToken
return ParsedTokenSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::InitializerClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Equal
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Equal
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::equal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Value
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Value
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FunctionParameter: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[8];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] FirstName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check FirstName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier || TokKind == tok::kw__;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] SecondName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check SecondName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier || TokKind == tok::kw__;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Type
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Type
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] Ellipsis
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Ellipsis
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::ellipsis;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] DefaultArgument
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DefaultArgument
return ParsedInitializerClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[7] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[7] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[7] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ModifierList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::ModifierList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FunctionDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[8];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] FuncKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check FuncKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_func;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier || TokKind == tok::oper_binary_unspaced || TokKind == tok::oper_binary_spaced || TokKind == tok::oper_prefix || TokKind == tok::oper_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] GenericParameterClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericParameterClause
return ParsedGenericParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] Signature
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Signature
return ParsedFunctionSignatureSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[7] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[7] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[7] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::InitializerDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[9];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] InitKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InitKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_init;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] OptionalMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check OptionalMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::question_postfix || TokKind == tok::question_infix || TokKind == tok::exclaim_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] GenericParameterClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericParameterClause
return ParsedGenericParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] Parameters
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Parameters
return ParsedParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] ThrowsOrRethrowsKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ThrowsOrRethrowsKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_throws || TokKind == tok::kw_rethrows;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[7] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[7] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[7] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[8] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[8] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[8] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DeinitializerDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] DeinitKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DeinitKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_deinit;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SubscriptDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[8];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] SubscriptKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check SubscriptKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_subscript;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] GenericParameterClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericParameterClause
return ParsedGenericParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Indices
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Indices
return ParsedParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] Result
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Result
return ParsedReturnClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[7] Accessor
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Accessor
return [](const ParsedRawSyntaxNode &Raw) {
 // check Accessors
return ParsedAccessorBlockSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Getter
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[7] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[7] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AccessLevelModifier: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Modifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AccessPathComponent: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TrailingDot
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingDot
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::period;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AccessPath: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::AccessPath, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ImportDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ImportTok
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ImportTok
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_import;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] ImportKind
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ImportKind
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_typealias || TokKind == tok::kw_struct || TokKind == tok::kw_class || TokKind == tok::kw_enum || TokKind == tok::kw_protocol || TokKind == tok::kw_var || TokKind == tok::kw_let || TokKind == tok::kw_func;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Path
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Path
return ParsedAccessPathSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AccessorParameter: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AccessorDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifier
return ParsedDeclModifierSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] AccessorKind
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AccessorKind
return Raw.isToken();
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Parameter
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Parameter
return ParsedAccessorParameterSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AccessorList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::AccessorList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AccessorBlock: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Accessors
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Accessors
return ParsedAccessorListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PatternBinding: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Pattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Pattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TypeAnnotation
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypeAnnotation
return ParsedTypeAnnotationSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Initializer
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Initializer
return ParsedInitializerClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Accessor
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Accessor
return [](const ParsedRawSyntaxNode &Raw) {
 // check Accessors
return ParsedAccessorBlockSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Getter
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PatternBindingList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::PatternBindingList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::VariableDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] LetOrVarKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LetOrVarKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_let || TokKind == tok::kw_var;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Bindings
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Bindings
return ParsedPatternBindingListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::EnumCaseElement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] AssociatedValue
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AssociatedValue
return ParsedParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RawValue
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RawValue
return ParsedInitializerClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::EnumCaseElementList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::EnumCaseElementList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::EnumCaseDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] CaseKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CaseKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_case;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Elements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Elements
return ParsedEnumCaseElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::EnumDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[8];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] EnumKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check EnumKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_enum;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] GenericParameters
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericParameters
return ParsedGenericParameterClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] InheritanceClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InheritanceClause
return ParsedTypeInheritanceClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] GenericWhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericWhereClause
return ParsedGenericWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[7] Members
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Members
return ParsedMemberDeclBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[7] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::OperatorDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] OperatorKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check OperatorKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_operator;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::oper_binary_unspaced || TokKind == tok::oper_binary_spaced || TokKind == tok::oper_prefix || TokKind == tok::oper_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] OperatorPrecedenceAndTypes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check OperatorPrecedenceAndTypes
return ParsedOperatorPrecedenceAndTypesSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IdentifierList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::IdentifierList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::OperatorPrecedenceAndTypes: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] PrecedenceGroupAndDesignatedTypes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PrecedenceGroupAndDesignatedTypes
return ParsedIdentifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PrecedenceGroupDecl: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[7];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Modifiers
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Modifiers
return ParsedModifierListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] PrecedencegroupKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PrecedencegroupKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_precedencegroup;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] LeftBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] GroupAttributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GroupAttributes
return ParsedPrecedenceGroupAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] RightBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PrecedenceGroupAttributeList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::PrecedenceGroupAttributeList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PrecedenceGroupRelation: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] HigherThanOrLowerThan
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check HigherThanOrLowerThan
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] OtherNames
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check OtherNames
return ParsedPrecedenceGroupNameListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PrecedenceGroupNameList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::PrecedenceGroupNameList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PrecedenceGroupNameElement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PrecedenceGroupAssignment: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] AssignmentKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AssignmentKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Flag
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Flag
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_true || TokKind == tok::kw_false;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PrecedenceGroupAssociativity: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] AssociativityKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AssociativityKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Value
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Value
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TokenList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::TokenList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::NonEmptyTokenList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::NonEmptyTokenList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CustomAttribute: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] AtSignToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AtSignToken
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::at_sign;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] AttributeName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AttributeName
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] ArgumentList
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ArgumentList
return ParsedFunctionCallArgumentListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::Attribute: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[6];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] AtSignToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AtSignToken
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::at_sign;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] AttributeName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AttributeName
return ParsedTokenSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Argument
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Argument
return [](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check String
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::string_literal;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Integer
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::integer_literal;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Availability
return ParsedAvailabilitySpecListSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check SpecializeArguments
return ParsedSpecializeAttributeSpecListSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check ObjCName
return ParsedObjCSelectorSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check ImplementsArguments
return ParsedImplementsAttributeArgumentsSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check NamedAttributeString
return ParsedNamedAttributeStringArgumentSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] TokenList
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TokenList
return ParsedTokenListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AttributeList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::AttributeList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SpecializeAttributeSpecList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::SpecializeAttributeSpecList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::LabeledSpecializeEntry: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Label
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Label
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Value
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Value
return ParsedTokenSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::NamedAttributeStringArgument: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] NameTok
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check NameTok
return ParsedTokenSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] StringOrDeclname
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check StringOrDeclname
return [](const ParsedRawSyntaxNode &Raw) {
 // check String
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::string_literal;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Declname
return ParsedDeclNameSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DeclName: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] DeclBaseName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DeclBaseName
return [](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Operator
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::oper_prefix;
}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] DeclNameArguments
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DeclNameArguments
return ParsedDeclNameArgumentsSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ImplementsAttributeArguments: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Type
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Type
return ParsedSimpleTypeIdentifierSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Comma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Comma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] DeclBaseName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DeclBaseName
return [](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Operator
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::oper_prefix;
}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] DeclNameArguments
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DeclNameArguments
return ParsedDeclNameArgumentsSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ObjCSelectorPiece: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ObjCSelector: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::ObjCSelector, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ContinueStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] ContinueKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ContinueKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_continue;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Label
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Label
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::WhileStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LabelName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LabelColon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelColon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] WhileKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check WhileKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_while;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Conditions
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Conditions
return ParsedConditionElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DeferStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] DeferKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DeferKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_defer;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ExpressionStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SwitchCaseList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::SwitchCaseList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::RepeatWhileStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[6];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LabelName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LabelColon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelColon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RepeatKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RepeatKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_repeat;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] WhileKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check WhileKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_while;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] Condition
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Condition
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::GuardStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] GuardKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GuardKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_guard;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Conditions
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Conditions
return ParsedConditionElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ElseKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ElseKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_else;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::WhereClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] WhereKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check WhereKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_where;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] GuardResult
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GuardResult
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ForInStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[10];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LabelName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LabelColon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelColon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] ForKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ForKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_for;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] CaseKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CaseKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_case;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Pattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Pattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] TypeAnnotation
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypeAnnotation
return ParsedTypeAnnotationSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] InKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_in;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[7] SequenceExpr
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check SequenceExpr
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[7] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[8] WhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check WhereClause
return ParsedWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[8] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[8] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[9] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[9] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SwitchStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[7];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LabelName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LabelColon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelColon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] SwitchKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check SwitchKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_switch;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] LeftBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] Cases
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Cases
return ParsedSwitchCaseListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] RightBrace
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightBrace
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_brace;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CatchClauseList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::CatchClauseList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DoStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LabelName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LabelColon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelColon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] DoKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DoKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_do;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] CatchClauses
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CatchClauses
return ParsedCatchClauseListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ReturnStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] ReturnKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ReturnKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_return;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::YieldStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] YieldKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check YieldKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_yield;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Yields
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Yields
return [](const ParsedRawSyntaxNode &Raw) {
 // check YieldList
return ParsedYieldListSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check SimpleYield
return ParsedExprSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::YieldList: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ElementList
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ElementList
return ParsedExprListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FallthroughStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] FallthroughKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check FallthroughKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_fallthrough;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::BreakStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] BreakKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check BreakKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_break;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Label
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Label
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CaseItemList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::CaseItemList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ConditionElement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Condition
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Condition
return [](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Availablity
return ParsedAvailabilityConditionSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check MatchingPattern
return ParsedMatchingPatternConditionSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check OptionalBinding
return ParsedOptionalBindingConditionSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AvailabilityCondition: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundAvailableKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundAvailableKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_available;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] AvailabilitySpec
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AvailabilitySpec
return ParsedAvailabilitySpecListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::MatchingPatternCondition: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] CaseKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CaseKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_case;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Pattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Pattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] TypeAnnotation
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypeAnnotation
return ParsedTypeAnnotationSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Initializer
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Initializer
return ParsedInitializerClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::OptionalBindingCondition: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LetOrVarKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LetOrVarKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_let || TokKind == tok::kw_var;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Pattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Pattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] TypeAnnotation
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypeAnnotation
return ParsedTypeAnnotationSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Initializer
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Initializer
return ParsedInitializerClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ConditionElementList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::ConditionElementList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DeclarationStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Declaration
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Declaration
return ParsedDeclSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ThrowStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] ThrowKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ThrowKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_throw;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IfStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[7];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LabelName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LabelColon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelColon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] IfKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check IfKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_if;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Conditions
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Conditions
return ParsedConditionElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] ElseKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ElseKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_else;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] ElseBody
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ElseBody
return [](const ParsedRawSyntaxNode &Raw) {
 // check IfStmt
return ParsedIfStmtSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check CodeBlock
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ElseIfContinuation: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] IfStatement
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check IfStatement
return ParsedIfStmtSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ElseBlock: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] ElseKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ElseKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_else;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SwitchCase: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] UnknownAttr
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check UnknownAttr
return ParsedAttributeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Label
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Label
return [](const ParsedRawSyntaxNode &Raw) {
 // check Default
return ParsedSwitchDefaultLabelSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Case
return ParsedSwitchCaseLabelSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Statements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Statements
return ParsedCodeBlockItemListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SwitchDefaultLabel: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] DefaultKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check DefaultKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_default;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CaseItem: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Pattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Pattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] WhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check WhereClause
return ParsedWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SwitchCaseLabel: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] CaseKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CaseKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_case;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] CaseItems
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CaseItems
return ParsedCaseItemListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CatchClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] CatchKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CatchKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_catch;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Pattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Pattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] WhereClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check WhereClause
return ParsedWhereClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Body
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Body
return ParsedCodeBlockSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::PoundAssertStmt: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[6];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] PoundAssert
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PoundAssert
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::pound_assert;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Condition
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Condition
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Comma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Comma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Message
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Message
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::string_literal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::GenericWhereClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] WhereKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check WhereKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_where;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] RequirementList
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RequirementList
return ParsedGenericRequirementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::GenericRequirementList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::GenericRequirementList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SameTypeRequirement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftTypeIdentifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftTypeIdentifier
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] EqualityToken
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check EqualityToken
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::oper_binary_spaced || TokKind == tok::oper_binary_unspaced;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightTypeIdentifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightTypeIdentifier
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::GenericParameterList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::GenericParameterList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::GenericParameter: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] InheritedType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InheritedType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::GenericParameterClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftAngleBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftAngleBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_angle;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] GenericParameterList
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericParameterList
return ParsedGenericParameterListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightAngleBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightAngleBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_angle;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ConformanceRequirement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftTypeIdentifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftTypeIdentifier
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightTypeIdentifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightTypeIdentifier
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SimpleTypeIdentifier: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier || TokKind == tok::kw_Self || TokKind == tok::kw_Any;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] GenericArgumentClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericArgumentClause
return ParsedGenericArgumentClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::MemberTypeIdentifier: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] BaseType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check BaseType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Period
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Period
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::period || TokKind == tok::period_prefix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier || TokKind == tok::kw_Self || TokKind == tok::kw_Any;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] GenericArgumentClause
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check GenericArgumentClause
return ParsedGenericArgumentClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ClassRestrictionType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] ClassKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ClassKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_class;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ArrayType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftSquareBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftSquareBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ElementType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ElementType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightSquareBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightSquareBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::DictionaryType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[5];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftSquareBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftSquareBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] KeyType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check KeyType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] ValueType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ValueType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] RightSquareBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightSquareBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_square;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::MetatypeType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] BaseType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check BaseType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Period
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Period
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::period;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] TypeOrProtocol
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypeOrProtocol
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::OptionalType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] WrappedType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check WrappedType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] QuestionMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check QuestionMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::question_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::SomeType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] SomeSpecifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check SomeSpecifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] BaseType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check BaseType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ImplicitlyUnwrappedOptionalType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] WrappedType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check WrappedType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ExclamationMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ExclamationMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::exclaim_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CompositionTypeElement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Type
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Type
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Ampersand
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Ampersand
return Raw.isToken();
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CompositionTypeElementList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::CompositionTypeElementList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::CompositionType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Elements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Elements
return ParsedCompositionTypeElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TupleTypeElement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[8];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] InOut
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check InOut
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_inout;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Name
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Name
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier || TokKind == tok::kw__;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] SecondName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check SecondName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier || TokKind == tok::kw__;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Type
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Type
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] Ellipsis
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Ellipsis
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::ellipsis;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[5] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[6] Initializer
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Initializer
return ParsedInitializerClauseSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[6] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[6] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[7] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[7] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[7] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TupleTypeElementList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::TupleTypeElementList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TupleType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Elements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Elements
return ParsedTupleTypeElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::FunctionType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[6];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Arguments
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Arguments
return ParsedTupleTypeElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] ThrowsOrRethrowsKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ThrowsOrRethrowsKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_throws || TokKind == tok::kw_rethrows || TokKind == tok::kw_throw;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[4] Arrow
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Arrow
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::arrow;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[4] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[5] ReturnType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ReturnType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[5] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AttributedType: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Specifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Specifier
return Raw.isToken();
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Attributes
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Attributes
return ParsedAttributeListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] BaseType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check BaseType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::GenericArgumentList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::GenericArgumentList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::GenericArgument: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] ArgumentType
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ArgumentType
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::GenericArgumentClause: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftAngleBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftAngleBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_angle;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Arguments
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Arguments
return ParsedGenericArgumentListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightAngleBracket
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightAngleBracket
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_angle;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TypeAnnotation: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Type
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Type
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::EnumCasePattern: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Type
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Type
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Period
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Period
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::period;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] CaseName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check CaseName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] AssociatedTuple
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AssociatedTuple
return ParsedTuplePatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IsTypePattern: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] IsKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check IsKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_is;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Type
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Type
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::OptionalPattern: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] SubPattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check SubPattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] QuestionMark
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check QuestionMark
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::question_postfix;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::IdentifierPattern: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Identifier
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Identifier
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_self || TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AsTypePattern: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Pattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Pattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] AsKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check AsKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_as;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Type
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Type
return ParsedTypeSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TuplePattern: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LeftParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LeftParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::l_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Elements
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Elements
return ParsedTuplePatternElementListSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] RightParen
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check RightParen
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::r_paren;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::WildcardPattern: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Wildcard
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Wildcard
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw__;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TypeAnnotation
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TypeAnnotation
return ParsedTypeAnnotationSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TuplePatternElement: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[4];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LabelName
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelName
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] LabelColon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LabelColon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Pattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Pattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[3] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[3] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[3] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ExpressionPattern: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[1];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Expression
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Expression
return ParsedExprSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::TuplePatternElementList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::TuplePatternElementList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::ValueBindingPattern: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] LetOrVarKeyword
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check LetOrVarKeyword
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::kw_let || TokKind == tok::kw_var;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] ValuePattern
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check ValuePattern
return ParsedPatternSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AvailabilitySpecList: {
#line 57 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    for (auto &E : Elements) {
      if (!SyntaxFactory::canServeAsCollectionMemberRaw(SyntaxKind::AvailabilitySpecList, E.getKind()))
        return false;
    }
    receiver(Kind, Elements);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AvailabilityArgument: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Entry
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Entry
return [](const ParsedRawSyntaxNode &Raw) {
 // check Star
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::oper_binary_spaced;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check IdentifierRestriction
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check AvailabilityVersionRestriction
return ParsedAvailabilityVersionRestrictionSyntax::kindof(Raw.getKind());}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check AvailabilityLabeledArgument
return ParsedAvailabilityLabeledArgumentSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] TrailingComma
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check TrailingComma
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::comma;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AvailabilityLabeledArgument: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Label
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Label
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Colon
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Colon
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::colon;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] Value
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Value
return [](const ParsedRawSyntaxNode &Raw) {
 // check String
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::string_literal;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check Version
return ParsedVersionTupleSyntax::kindof(Raw.getKind());}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::AvailabilityVersionRestriction: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[2];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] Platform
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Platform
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::identifier;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] Version
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check Version
return ParsedVersionTupleSyntax::kindof(Raw.getKind());}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 33 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  case SyntaxKind::VersionTuple: {
#line 36 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParsedRawSyntaxNode Layout[3];
    unsigned I = 0;
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[0] MajorMinor
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check MajorMinor
return [](const ParsedRawSyntaxNode &Raw) {
 // check Major
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::integer_literal;
}(Raw) || [](const ParsedRawSyntaxNode &Raw) {
 // check MajorMinor
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::floating_literal;
}(Raw);
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      return false;
#line 46 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
#line 48 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[0] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[1] PatchPeriod
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PatchPeriod
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::period;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[1] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[1] = Elements[I];
      ++I;
    }
#line 39 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    // child[2] PatchVersion
    if (I == Elements.size() ||
        ![](const ParsedRawSyntaxNode &Raw) {
 // check PatchVersion
if (!Raw.isToken()) return false;
auto TokKind = Raw.getTokenKind();
return TokKind == tok::integer_literal;
}(Elements[I])) {
#line 42 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
      Layout[2] = ParsedRawSyntaxNode::null();
#line 47 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    } else {
      Layout[2] = Elements[I];
      ++I;
    }
#line 52 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    if (I != Elements.size())
      return false;
    receiver(Kind, Layout);
    return true;
#line 66 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }
#line 68 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  default:
    return false;
  }
}

#line 172 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedUnknownDeclSyntax
ParsedSyntaxRecorder::recordUnknownDecl(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::UnknownDecl, layout);
  return ParsedUnknownDeclSyntax(std::move(raw));
}

ParsedUnknownDeclSyntax
ParsedSyntaxRecorder::deferUnknownDecl(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::UnknownDecl, layout, SPCtx);
  return ParsedUnknownDeclSyntax(std::move(raw));
}

ParsedUnknownDeclSyntax
ParsedSyntaxRecorder::makeUnknownDecl(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferUnknownDecl(elements, SPCtx);
  return recordUnknownDecl(elements, SPCtx.getRecorder());
}
#line 172 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedUnknownExprSyntax
ParsedSyntaxRecorder::recordUnknownExpr(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::UnknownExpr, layout);
  return ParsedUnknownExprSyntax(std::move(raw));
}

ParsedUnknownExprSyntax
ParsedSyntaxRecorder::deferUnknownExpr(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::UnknownExpr, layout, SPCtx);
  return ParsedUnknownExprSyntax(std::move(raw));
}

ParsedUnknownExprSyntax
ParsedSyntaxRecorder::makeUnknownExpr(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferUnknownExpr(elements, SPCtx);
  return recordUnknownExpr(elements, SPCtx.getRecorder());
}
#line 172 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedUnknownStmtSyntax
ParsedSyntaxRecorder::recordUnknownStmt(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::UnknownStmt, layout);
  return ParsedUnknownStmtSyntax(std::move(raw));
}

ParsedUnknownStmtSyntax
ParsedSyntaxRecorder::deferUnknownStmt(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::UnknownStmt, layout, SPCtx);
  return ParsedUnknownStmtSyntax(std::move(raw));
}

ParsedUnknownStmtSyntax
ParsedSyntaxRecorder::makeUnknownStmt(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferUnknownStmt(elements, SPCtx);
  return recordUnknownStmt(elements, SPCtx.getRecorder());
}
#line 172 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedUnknownTypeSyntax
ParsedSyntaxRecorder::recordUnknownType(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::UnknownType, layout);
  return ParsedUnknownTypeSyntax(std::move(raw));
}

ParsedUnknownTypeSyntax
ParsedSyntaxRecorder::deferUnknownType(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::UnknownType, layout, SPCtx);
  return ParsedUnknownTypeSyntax(std::move(raw));
}

ParsedUnknownTypeSyntax
ParsedSyntaxRecorder::makeUnknownType(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferUnknownType(elements, SPCtx);
  return recordUnknownType(elements, SPCtx.getRecorder());
}
#line 172 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedUnknownPatternSyntax
ParsedSyntaxRecorder::recordUnknownPattern(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::UnknownPattern, layout);
  return ParsedUnknownPatternSyntax(std::move(raw));
}

ParsedUnknownPatternSyntax
ParsedSyntaxRecorder::deferUnknownPattern(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::UnknownPattern, layout, SPCtx);
  return ParsedUnknownPatternSyntax(std::move(raw));
}

ParsedUnknownPatternSyntax
ParsedSyntaxRecorder::makeUnknownPattern(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferUnknownPattern(elements, SPCtx);
  return recordUnknownPattern(elements, SPCtx.getRecorder());
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCodeBlockItemSyntax
ParsedSyntaxRecorder::recordCodeBlockItem(ParsedSyntax Item, Optional<ParsedTokenSyntax> Semicolon, Optional<ParsedSyntax> ErrorTokens,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::CodeBlockItem, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Item.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Semicolon.hasValue() ? Semicolon->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ErrorTokens.hasValue() ? ErrorTokens->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedCodeBlockItemSyntax(std::move(raw));
}

ParsedCodeBlockItemSyntax
ParsedSyntaxRecorder::deferCodeBlockItem(ParsedSyntax Item, Optional<ParsedTokenSyntax> Semicolon, Optional<ParsedSyntax> ErrorTokens, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CodeBlockItem, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Item.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Semicolon.hasValue() ? Semicolon->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ErrorTokens.hasValue() ? ErrorTokens->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedCodeBlockItemSyntax(std::move(raw));
}

ParsedCodeBlockItemSyntax
ParsedSyntaxRecorder::makeCodeBlockItem(ParsedSyntax Item, Optional<ParsedTokenSyntax> Semicolon, Optional<ParsedSyntax> ErrorTokens,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCodeBlockItem(std::move(Item), std::move(Semicolon), std::move(ErrorTokens), SPCtx);
  return recordCodeBlockItem(std::move(Item), std::move(Semicolon), std::move(ErrorTokens), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCodeBlockItemListSyntax
ParsedSyntaxRecorder::recordCodeBlockItemList(
    ArrayRef<ParsedCodeBlockItemSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::CodeBlockItemList, layout);
  return ParsedCodeBlockItemListSyntax(std::move(raw));
}

ParsedCodeBlockItemListSyntax
ParsedSyntaxRecorder::deferCodeBlockItemList(
    ArrayRef<ParsedCodeBlockItemSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CodeBlockItemList,
                             layout, SPCtx);
  return ParsedCodeBlockItemListSyntax(std::move(raw));
}

ParsedCodeBlockItemListSyntax
ParsedSyntaxRecorder::makeCodeBlockItemList(
    ArrayRef<ParsedCodeBlockItemSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCodeBlockItemList(elements, SPCtx);
  return recordCodeBlockItemList(elements, SPCtx.getRecorder());
}

ParsedCodeBlockItemListSyntax
ParsedSyntaxRecorder::makeBlankCodeBlockItemList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CodeBlockItemList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::CodeBlockItemList, loc);
  }
  return ParsedCodeBlockItemListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCodeBlockSyntax
ParsedSyntaxRecorder::recordCodeBlock(ParsedTokenSyntax LeftBrace, ParsedCodeBlockItemListSyntax Statements, ParsedTokenSyntax RightBrace,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::CodeBlock, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Statements.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedCodeBlockSyntax(std::move(raw));
}

ParsedCodeBlockSyntax
ParsedSyntaxRecorder::deferCodeBlock(ParsedTokenSyntax LeftBrace, ParsedCodeBlockItemListSyntax Statements, ParsedTokenSyntax RightBrace, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CodeBlock, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Statements.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedCodeBlockSyntax(std::move(raw));
}

ParsedCodeBlockSyntax
ParsedSyntaxRecorder::makeCodeBlock(ParsedTokenSyntax LeftBrace, ParsedCodeBlockItemListSyntax Statements, ParsedTokenSyntax RightBrace,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCodeBlock(std::move(LeftBrace), std::move(Statements), std::move(RightBrace), SPCtx);
  return recordCodeBlock(std::move(LeftBrace), std::move(Statements), std::move(RightBrace), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedInOutExprSyntax
ParsedSyntaxRecorder::recordInOutExpr(ParsedTokenSyntax Ampersand, ParsedExprSyntax Expression,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::InOutExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Ampersand.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedInOutExprSyntax(std::move(raw));
}

ParsedInOutExprSyntax
ParsedSyntaxRecorder::deferInOutExpr(ParsedTokenSyntax Ampersand, ParsedExprSyntax Expression, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::InOutExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Ampersand.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedInOutExprSyntax(std::move(raw));
}

ParsedInOutExprSyntax
ParsedSyntaxRecorder::makeInOutExpr(ParsedTokenSyntax Ampersand, ParsedExprSyntax Expression,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferInOutExpr(std::move(Ampersand), std::move(Expression), SPCtx);
  return recordInOutExpr(std::move(Ampersand), std::move(Expression), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundColumnExprSyntax
ParsedSyntaxRecorder::recordPoundColumnExpr(ParsedTokenSyntax PoundColumn,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundColumnExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundColumn.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundColumnExprSyntax(std::move(raw));
}

ParsedPoundColumnExprSyntax
ParsedSyntaxRecorder::deferPoundColumnExpr(ParsedTokenSyntax PoundColumn, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundColumnExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundColumn.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundColumnExprSyntax(std::move(raw));
}

ParsedPoundColumnExprSyntax
ParsedSyntaxRecorder::makePoundColumnExpr(ParsedTokenSyntax PoundColumn,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundColumnExpr(std::move(PoundColumn), SPCtx);
  return recordPoundColumnExpr(std::move(PoundColumn), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFunctionCallArgumentListSyntax
ParsedSyntaxRecorder::recordFunctionCallArgumentList(
    ArrayRef<ParsedFunctionCallArgumentSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::FunctionCallArgumentList, layout);
  return ParsedFunctionCallArgumentListSyntax(std::move(raw));
}

ParsedFunctionCallArgumentListSyntax
ParsedSyntaxRecorder::deferFunctionCallArgumentList(
    ArrayRef<ParsedFunctionCallArgumentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionCallArgumentList,
                             layout, SPCtx);
  return ParsedFunctionCallArgumentListSyntax(std::move(raw));
}

ParsedFunctionCallArgumentListSyntax
ParsedSyntaxRecorder::makeFunctionCallArgumentList(
    ArrayRef<ParsedFunctionCallArgumentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFunctionCallArgumentList(elements, SPCtx);
  return recordFunctionCallArgumentList(elements, SPCtx.getRecorder());
}

ParsedFunctionCallArgumentListSyntax
ParsedSyntaxRecorder::makeBlankFunctionCallArgumentList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionCallArgumentList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::FunctionCallArgumentList, loc);
  }
  return ParsedFunctionCallArgumentListSyntax(std::move(raw));
}
#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTupleElementListSyntax
ParsedSyntaxRecorder::recordTupleElementList(
    ArrayRef<ParsedTupleElementSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::TupleElementList, layout);
  return ParsedTupleElementListSyntax(std::move(raw));
}

ParsedTupleElementListSyntax
ParsedSyntaxRecorder::deferTupleElementList(
    ArrayRef<ParsedTupleElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TupleElementList,
                             layout, SPCtx);
  return ParsedTupleElementListSyntax(std::move(raw));
}

ParsedTupleElementListSyntax
ParsedSyntaxRecorder::makeTupleElementList(
    ArrayRef<ParsedTupleElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTupleElementList(elements, SPCtx);
  return recordTupleElementList(elements, SPCtx.getRecorder());
}

ParsedTupleElementListSyntax
ParsedSyntaxRecorder::makeBlankTupleElementList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TupleElementList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::TupleElementList, loc);
  }
  return ParsedTupleElementListSyntax(std::move(raw));
}
#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedArrayElementListSyntax
ParsedSyntaxRecorder::recordArrayElementList(
    ArrayRef<ParsedArrayElementSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::ArrayElementList, layout);
  return ParsedArrayElementListSyntax(std::move(raw));
}

ParsedArrayElementListSyntax
ParsedSyntaxRecorder::deferArrayElementList(
    ArrayRef<ParsedArrayElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ArrayElementList,
                             layout, SPCtx);
  return ParsedArrayElementListSyntax(std::move(raw));
}

ParsedArrayElementListSyntax
ParsedSyntaxRecorder::makeArrayElementList(
    ArrayRef<ParsedArrayElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferArrayElementList(elements, SPCtx);
  return recordArrayElementList(elements, SPCtx.getRecorder());
}

ParsedArrayElementListSyntax
ParsedSyntaxRecorder::makeBlankArrayElementList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ArrayElementList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::ArrayElementList, loc);
  }
  return ParsedArrayElementListSyntax(std::move(raw));
}
#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDictionaryElementListSyntax
ParsedSyntaxRecorder::recordDictionaryElementList(
    ArrayRef<ParsedDictionaryElementSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::DictionaryElementList, layout);
  return ParsedDictionaryElementListSyntax(std::move(raw));
}

ParsedDictionaryElementListSyntax
ParsedSyntaxRecorder::deferDictionaryElementList(
    ArrayRef<ParsedDictionaryElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DictionaryElementList,
                             layout, SPCtx);
  return ParsedDictionaryElementListSyntax(std::move(raw));
}

ParsedDictionaryElementListSyntax
ParsedSyntaxRecorder::makeDictionaryElementList(
    ArrayRef<ParsedDictionaryElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDictionaryElementList(elements, SPCtx);
  return recordDictionaryElementList(elements, SPCtx.getRecorder());
}

ParsedDictionaryElementListSyntax
ParsedSyntaxRecorder::makeBlankDictionaryElementList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DictionaryElementList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::DictionaryElementList, loc);
  }
  return ParsedDictionaryElementListSyntax(std::move(raw));
}
#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedStringLiteralSegmentsSyntax
ParsedSyntaxRecorder::recordStringLiteralSegments(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::StringLiteralSegments, layout);
  return ParsedStringLiteralSegmentsSyntax(std::move(raw));
}

ParsedStringLiteralSegmentsSyntax
ParsedSyntaxRecorder::deferStringLiteralSegments(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::StringLiteralSegments,
                             layout, SPCtx);
  return ParsedStringLiteralSegmentsSyntax(std::move(raw));
}

ParsedStringLiteralSegmentsSyntax
ParsedSyntaxRecorder::makeStringLiteralSegments(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferStringLiteralSegments(elements, SPCtx);
  return recordStringLiteralSegments(elements, SPCtx.getRecorder());
}

ParsedStringLiteralSegmentsSyntax
ParsedSyntaxRecorder::makeBlankStringLiteralSegments(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::StringLiteralSegments, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::StringLiteralSegments, loc);
  }
  return ParsedStringLiteralSegmentsSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTryExprSyntax
ParsedSyntaxRecorder::recordTryExpr(ParsedTokenSyntax TryKeyword, Optional<ParsedTokenSyntax> QuestionOrExclamationMark, ParsedExprSyntax Expression,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TryExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TryKeyword.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionOrExclamationMark.hasValue() ? QuestionOrExclamationMark->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTryExprSyntax(std::move(raw));
}

ParsedTryExprSyntax
ParsedSyntaxRecorder::deferTryExpr(ParsedTokenSyntax TryKeyword, Optional<ParsedTokenSyntax> QuestionOrExclamationMark, ParsedExprSyntax Expression, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TryExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TryKeyword.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionOrExclamationMark.hasValue() ? QuestionOrExclamationMark->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTryExprSyntax(std::move(raw));
}

ParsedTryExprSyntax
ParsedSyntaxRecorder::makeTryExpr(ParsedTokenSyntax TryKeyword, Optional<ParsedTokenSyntax> QuestionOrExclamationMark, ParsedExprSyntax Expression,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTryExpr(std::move(TryKeyword), std::move(QuestionOrExclamationMark), std::move(Expression), SPCtx);
  return recordTryExpr(std::move(TryKeyword), std::move(QuestionOrExclamationMark), std::move(Expression), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDeclNameArgumentSyntax
ParsedSyntaxRecorder::recordDeclNameArgument(ParsedTokenSyntax Name, ParsedTokenSyntax Colon,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DeclNameArgument, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDeclNameArgumentSyntax(std::move(raw));
}

ParsedDeclNameArgumentSyntax
ParsedSyntaxRecorder::deferDeclNameArgument(ParsedTokenSyntax Name, ParsedTokenSyntax Colon, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DeclNameArgument, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDeclNameArgumentSyntax(std::move(raw));
}

ParsedDeclNameArgumentSyntax
ParsedSyntaxRecorder::makeDeclNameArgument(ParsedTokenSyntax Name, ParsedTokenSyntax Colon,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDeclNameArgument(std::move(Name), std::move(Colon), SPCtx);
  return recordDeclNameArgument(std::move(Name), std::move(Colon), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDeclNameArgumentListSyntax
ParsedSyntaxRecorder::recordDeclNameArgumentList(
    ArrayRef<ParsedDeclNameArgumentSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::DeclNameArgumentList, layout);
  return ParsedDeclNameArgumentListSyntax(std::move(raw));
}

ParsedDeclNameArgumentListSyntax
ParsedSyntaxRecorder::deferDeclNameArgumentList(
    ArrayRef<ParsedDeclNameArgumentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DeclNameArgumentList,
                             layout, SPCtx);
  return ParsedDeclNameArgumentListSyntax(std::move(raw));
}

ParsedDeclNameArgumentListSyntax
ParsedSyntaxRecorder::makeDeclNameArgumentList(
    ArrayRef<ParsedDeclNameArgumentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDeclNameArgumentList(elements, SPCtx);
  return recordDeclNameArgumentList(elements, SPCtx.getRecorder());
}

ParsedDeclNameArgumentListSyntax
ParsedSyntaxRecorder::makeBlankDeclNameArgumentList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DeclNameArgumentList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::DeclNameArgumentList, loc);
  }
  return ParsedDeclNameArgumentListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDeclNameArgumentsSyntax
ParsedSyntaxRecorder::recordDeclNameArguments(ParsedTokenSyntax LeftParen, ParsedDeclNameArgumentListSyntax Arguments, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DeclNameArguments, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arguments.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDeclNameArgumentsSyntax(std::move(raw));
}

ParsedDeclNameArgumentsSyntax
ParsedSyntaxRecorder::deferDeclNameArguments(ParsedTokenSyntax LeftParen, ParsedDeclNameArgumentListSyntax Arguments, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DeclNameArguments, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arguments.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDeclNameArgumentsSyntax(std::move(raw));
}

ParsedDeclNameArgumentsSyntax
ParsedSyntaxRecorder::makeDeclNameArguments(ParsedTokenSyntax LeftParen, ParsedDeclNameArgumentListSyntax Arguments, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDeclNameArguments(std::move(LeftParen), std::move(Arguments), std::move(RightParen), SPCtx);
  return recordDeclNameArguments(std::move(LeftParen), std::move(Arguments), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIdentifierExprSyntax
ParsedSyntaxRecorder::recordIdentifierExpr(ParsedTokenSyntax Identifier, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::IdentifierExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclNameArguments.hasValue() ? DeclNameArguments->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedIdentifierExprSyntax(std::move(raw));
}

ParsedIdentifierExprSyntax
ParsedSyntaxRecorder::deferIdentifierExpr(ParsedTokenSyntax Identifier, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IdentifierExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclNameArguments.hasValue() ? DeclNameArguments->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedIdentifierExprSyntax(std::move(raw));
}

ParsedIdentifierExprSyntax
ParsedSyntaxRecorder::makeIdentifierExpr(ParsedTokenSyntax Identifier, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIdentifierExpr(std::move(Identifier), std::move(DeclNameArguments), SPCtx);
  return recordIdentifierExpr(std::move(Identifier), std::move(DeclNameArguments), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSuperRefExprSyntax
ParsedSyntaxRecorder::recordSuperRefExpr(ParsedTokenSyntax SuperKeyword,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SuperRefExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SuperKeyword.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSuperRefExprSyntax(std::move(raw));
}

ParsedSuperRefExprSyntax
ParsedSyntaxRecorder::deferSuperRefExpr(ParsedTokenSyntax SuperKeyword, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SuperRefExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SuperKeyword.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSuperRefExprSyntax(std::move(raw));
}

ParsedSuperRefExprSyntax
ParsedSyntaxRecorder::makeSuperRefExpr(ParsedTokenSyntax SuperKeyword,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSuperRefExpr(std::move(SuperKeyword), SPCtx);
  return recordSuperRefExpr(std::move(SuperKeyword), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedNilLiteralExprSyntax
ParsedSyntaxRecorder::recordNilLiteralExpr(ParsedTokenSyntax NilKeyword,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::NilLiteralExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    NilKeyword.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedNilLiteralExprSyntax(std::move(raw));
}

ParsedNilLiteralExprSyntax
ParsedSyntaxRecorder::deferNilLiteralExpr(ParsedTokenSyntax NilKeyword, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::NilLiteralExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    NilKeyword.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedNilLiteralExprSyntax(std::move(raw));
}

ParsedNilLiteralExprSyntax
ParsedSyntaxRecorder::makeNilLiteralExpr(ParsedTokenSyntax NilKeyword,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferNilLiteralExpr(std::move(NilKeyword), SPCtx);
  return recordNilLiteralExpr(std::move(NilKeyword), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDiscardAssignmentExprSyntax
ParsedSyntaxRecorder::recordDiscardAssignmentExpr(ParsedTokenSyntax Wildcard,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DiscardAssignmentExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Wildcard.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDiscardAssignmentExprSyntax(std::move(raw));
}

ParsedDiscardAssignmentExprSyntax
ParsedSyntaxRecorder::deferDiscardAssignmentExpr(ParsedTokenSyntax Wildcard, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DiscardAssignmentExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Wildcard.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDiscardAssignmentExprSyntax(std::move(raw));
}

ParsedDiscardAssignmentExprSyntax
ParsedSyntaxRecorder::makeDiscardAssignmentExpr(ParsedTokenSyntax Wildcard,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDiscardAssignmentExpr(std::move(Wildcard), SPCtx);
  return recordDiscardAssignmentExpr(std::move(Wildcard), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAssignmentExprSyntax
ParsedSyntaxRecorder::recordAssignmentExpr(ParsedTokenSyntax AssignToken,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AssignmentExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssignToken.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAssignmentExprSyntax(std::move(raw));
}

ParsedAssignmentExprSyntax
ParsedSyntaxRecorder::deferAssignmentExpr(ParsedTokenSyntax AssignToken, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AssignmentExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssignToken.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAssignmentExprSyntax(std::move(raw));
}

ParsedAssignmentExprSyntax
ParsedSyntaxRecorder::makeAssignmentExpr(ParsedTokenSyntax AssignToken,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAssignmentExpr(std::move(AssignToken), SPCtx);
  return recordAssignmentExpr(std::move(AssignToken), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSequenceExprSyntax
ParsedSyntaxRecorder::recordSequenceExpr(ParsedExprListSyntax Elements,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SequenceExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSequenceExprSyntax(std::move(raw));
}

ParsedSequenceExprSyntax
ParsedSyntaxRecorder::deferSequenceExpr(ParsedExprListSyntax Elements, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SequenceExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSequenceExprSyntax(std::move(raw));
}

ParsedSequenceExprSyntax
ParsedSyntaxRecorder::makeSequenceExpr(ParsedExprListSyntax Elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSequenceExpr(std::move(Elements), SPCtx);
  return recordSequenceExpr(std::move(Elements), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedExprListSyntax
ParsedSyntaxRecorder::recordExprList(
    ArrayRef<ParsedExprSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::ExprList, layout);
  return ParsedExprListSyntax(std::move(raw));
}

ParsedExprListSyntax
ParsedSyntaxRecorder::deferExprList(
    ArrayRef<ParsedExprSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ExprList,
                             layout, SPCtx);
  return ParsedExprListSyntax(std::move(raw));
}

ParsedExprListSyntax
ParsedSyntaxRecorder::makeExprList(
    ArrayRef<ParsedExprSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferExprList(elements, SPCtx);
  return recordExprList(elements, SPCtx.getRecorder());
}

ParsedExprListSyntax
ParsedSyntaxRecorder::makeBlankExprList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ExprList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::ExprList, loc);
  }
  return ParsedExprListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundLineExprSyntax
ParsedSyntaxRecorder::recordPoundLineExpr(ParsedTokenSyntax PoundLine,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundLineExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundLine.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundLineExprSyntax(std::move(raw));
}

ParsedPoundLineExprSyntax
ParsedSyntaxRecorder::deferPoundLineExpr(ParsedTokenSyntax PoundLine, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundLineExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundLine.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundLineExprSyntax(std::move(raw));
}

ParsedPoundLineExprSyntax
ParsedSyntaxRecorder::makePoundLineExpr(ParsedTokenSyntax PoundLine,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundLineExpr(std::move(PoundLine), SPCtx);
  return recordPoundLineExpr(std::move(PoundLine), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundFileExprSyntax
ParsedSyntaxRecorder::recordPoundFileExpr(ParsedTokenSyntax PoundFile,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundFileExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundFile.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundFileExprSyntax(std::move(raw));
}

ParsedPoundFileExprSyntax
ParsedSyntaxRecorder::deferPoundFileExpr(ParsedTokenSyntax PoundFile, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundFileExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundFile.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundFileExprSyntax(std::move(raw));
}

ParsedPoundFileExprSyntax
ParsedSyntaxRecorder::makePoundFileExpr(ParsedTokenSyntax PoundFile,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundFileExpr(std::move(PoundFile), SPCtx);
  return recordPoundFileExpr(std::move(PoundFile), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundFunctionExprSyntax
ParsedSyntaxRecorder::recordPoundFunctionExpr(ParsedTokenSyntax PoundFunction,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundFunctionExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundFunction.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundFunctionExprSyntax(std::move(raw));
}

ParsedPoundFunctionExprSyntax
ParsedSyntaxRecorder::deferPoundFunctionExpr(ParsedTokenSyntax PoundFunction, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundFunctionExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundFunction.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundFunctionExprSyntax(std::move(raw));
}

ParsedPoundFunctionExprSyntax
ParsedSyntaxRecorder::makePoundFunctionExpr(ParsedTokenSyntax PoundFunction,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundFunctionExpr(std::move(PoundFunction), SPCtx);
  return recordPoundFunctionExpr(std::move(PoundFunction), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundDsohandleExprSyntax
ParsedSyntaxRecorder::recordPoundDsohandleExpr(ParsedTokenSyntax PoundDsohandle,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundDsohandleExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundDsohandle.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundDsohandleExprSyntax(std::move(raw));
}

ParsedPoundDsohandleExprSyntax
ParsedSyntaxRecorder::deferPoundDsohandleExpr(ParsedTokenSyntax PoundDsohandle, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundDsohandleExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundDsohandle.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundDsohandleExprSyntax(std::move(raw));
}

ParsedPoundDsohandleExprSyntax
ParsedSyntaxRecorder::makePoundDsohandleExpr(ParsedTokenSyntax PoundDsohandle,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundDsohandleExpr(std::move(PoundDsohandle), SPCtx);
  return recordPoundDsohandleExpr(std::move(PoundDsohandle), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSymbolicReferenceExprSyntax
ParsedSyntaxRecorder::recordSymbolicReferenceExpr(ParsedTokenSyntax Identifier, Optional<ParsedGenericArgumentClauseSyntax> GenericArgumentClause,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SymbolicReferenceExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericArgumentClause.hasValue() ? GenericArgumentClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSymbolicReferenceExprSyntax(std::move(raw));
}

ParsedSymbolicReferenceExprSyntax
ParsedSyntaxRecorder::deferSymbolicReferenceExpr(ParsedTokenSyntax Identifier, Optional<ParsedGenericArgumentClauseSyntax> GenericArgumentClause, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SymbolicReferenceExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericArgumentClause.hasValue() ? GenericArgumentClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSymbolicReferenceExprSyntax(std::move(raw));
}

ParsedSymbolicReferenceExprSyntax
ParsedSyntaxRecorder::makeSymbolicReferenceExpr(ParsedTokenSyntax Identifier, Optional<ParsedGenericArgumentClauseSyntax> GenericArgumentClause,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSymbolicReferenceExpr(std::move(Identifier), std::move(GenericArgumentClause), SPCtx);
  return recordSymbolicReferenceExpr(std::move(Identifier), std::move(GenericArgumentClause), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPrefixOperatorExprSyntax
ParsedSyntaxRecorder::recordPrefixOperatorExpr(Optional<ParsedTokenSyntax> OperatorToken, ParsedExprSyntax PostfixExpression,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PrefixOperatorExpr, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorToken.hasValue() ? OperatorToken->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PostfixExpression.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPrefixOperatorExprSyntax(std::move(raw));
}

ParsedPrefixOperatorExprSyntax
ParsedSyntaxRecorder::deferPrefixOperatorExpr(Optional<ParsedTokenSyntax> OperatorToken, ParsedExprSyntax PostfixExpression, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrefixOperatorExpr, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorToken.hasValue() ? OperatorToken->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PostfixExpression.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPrefixOperatorExprSyntax(std::move(raw));
}

ParsedPrefixOperatorExprSyntax
ParsedSyntaxRecorder::makePrefixOperatorExpr(Optional<ParsedTokenSyntax> OperatorToken, ParsedExprSyntax PostfixExpression,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPrefixOperatorExpr(std::move(OperatorToken), std::move(PostfixExpression), SPCtx);
  return recordPrefixOperatorExpr(std::move(OperatorToken), std::move(PostfixExpression), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedBinaryOperatorExprSyntax
ParsedSyntaxRecorder::recordBinaryOperatorExpr(ParsedTokenSyntax OperatorToken,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::BinaryOperatorExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorToken.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedBinaryOperatorExprSyntax(std::move(raw));
}

ParsedBinaryOperatorExprSyntax
ParsedSyntaxRecorder::deferBinaryOperatorExpr(ParsedTokenSyntax OperatorToken, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::BinaryOperatorExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorToken.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedBinaryOperatorExprSyntax(std::move(raw));
}

ParsedBinaryOperatorExprSyntax
ParsedSyntaxRecorder::makeBinaryOperatorExpr(ParsedTokenSyntax OperatorToken,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferBinaryOperatorExpr(std::move(OperatorToken), SPCtx);
  return recordBinaryOperatorExpr(std::move(OperatorToken), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedArrowExprSyntax
ParsedSyntaxRecorder::recordArrowExpr(Optional<ParsedTokenSyntax> ThrowsToken, ParsedTokenSyntax ArrowToken,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ArrowExpr, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsToken.hasValue() ? ThrowsToken->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArrowToken.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedArrowExprSyntax(std::move(raw));
}

ParsedArrowExprSyntax
ParsedSyntaxRecorder::deferArrowExpr(Optional<ParsedTokenSyntax> ThrowsToken, ParsedTokenSyntax ArrowToken, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ArrowExpr, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsToken.hasValue() ? ThrowsToken->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArrowToken.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedArrowExprSyntax(std::move(raw));
}

ParsedArrowExprSyntax
ParsedSyntaxRecorder::makeArrowExpr(Optional<ParsedTokenSyntax> ThrowsToken, ParsedTokenSyntax ArrowToken,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferArrowExpr(std::move(ThrowsToken), std::move(ArrowToken), SPCtx);
  return recordArrowExpr(std::move(ThrowsToken), std::move(ArrowToken), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFloatLiteralExprSyntax
ParsedSyntaxRecorder::recordFloatLiteralExpr(ParsedTokenSyntax FloatingDigits,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::FloatLiteralExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FloatingDigits.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedFloatLiteralExprSyntax(std::move(raw));
}

ParsedFloatLiteralExprSyntax
ParsedSyntaxRecorder::deferFloatLiteralExpr(ParsedTokenSyntax FloatingDigits, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FloatLiteralExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FloatingDigits.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedFloatLiteralExprSyntax(std::move(raw));
}

ParsedFloatLiteralExprSyntax
ParsedSyntaxRecorder::makeFloatLiteralExpr(ParsedTokenSyntax FloatingDigits,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFloatLiteralExpr(std::move(FloatingDigits), SPCtx);
  return recordFloatLiteralExpr(std::move(FloatingDigits), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTupleExprSyntax
ParsedSyntaxRecorder::recordTupleExpr(ParsedTokenSyntax LeftParen, ParsedTupleElementListSyntax ElementList, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TupleExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElementList.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTupleExprSyntax(std::move(raw));
}

ParsedTupleExprSyntax
ParsedSyntaxRecorder::deferTupleExpr(ParsedTokenSyntax LeftParen, ParsedTupleElementListSyntax ElementList, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TupleExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElementList.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTupleExprSyntax(std::move(raw));
}

ParsedTupleExprSyntax
ParsedSyntaxRecorder::makeTupleExpr(ParsedTokenSyntax LeftParen, ParsedTupleElementListSyntax ElementList, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTupleExpr(std::move(LeftParen), std::move(ElementList), std::move(RightParen), SPCtx);
  return recordTupleExpr(std::move(LeftParen), std::move(ElementList), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedArrayExprSyntax
ParsedSyntaxRecorder::recordArrayExpr(ParsedTokenSyntax LeftSquare, ParsedArrayElementListSyntax Elements, ParsedTokenSyntax RightSquare,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ArrayExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquare.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquare.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedArrayExprSyntax(std::move(raw));
}

ParsedArrayExprSyntax
ParsedSyntaxRecorder::deferArrayExpr(ParsedTokenSyntax LeftSquare, ParsedArrayElementListSyntax Elements, ParsedTokenSyntax RightSquare, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ArrayExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquare.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquare.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedArrayExprSyntax(std::move(raw));
}

ParsedArrayExprSyntax
ParsedSyntaxRecorder::makeArrayExpr(ParsedTokenSyntax LeftSquare, ParsedArrayElementListSyntax Elements, ParsedTokenSyntax RightSquare,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferArrayExpr(std::move(LeftSquare), std::move(Elements), std::move(RightSquare), SPCtx);
  return recordArrayExpr(std::move(LeftSquare), std::move(Elements), std::move(RightSquare), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDictionaryExprSyntax
ParsedSyntaxRecorder::recordDictionaryExpr(ParsedTokenSyntax LeftSquare, ParsedSyntax Content, ParsedTokenSyntax RightSquare,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DictionaryExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquare.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Content.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquare.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDictionaryExprSyntax(std::move(raw));
}

ParsedDictionaryExprSyntax
ParsedSyntaxRecorder::deferDictionaryExpr(ParsedTokenSyntax LeftSquare, ParsedSyntax Content, ParsedTokenSyntax RightSquare, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DictionaryExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquare.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Content.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquare.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDictionaryExprSyntax(std::move(raw));
}

ParsedDictionaryExprSyntax
ParsedSyntaxRecorder::makeDictionaryExpr(ParsedTokenSyntax LeftSquare, ParsedSyntax Content, ParsedTokenSyntax RightSquare,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDictionaryExpr(std::move(LeftSquare), std::move(Content), std::move(RightSquare), SPCtx);
  return recordDictionaryExpr(std::move(LeftSquare), std::move(Content), std::move(RightSquare), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFunctionCallArgumentSyntax
ParsedSyntaxRecorder::recordFunctionCallArgument(Optional<ParsedTokenSyntax> Label, Optional<ParsedTokenSyntax> Colon, ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::FunctionCallArgument, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.hasValue() ? Label->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedFunctionCallArgumentSyntax(std::move(raw));
}

ParsedFunctionCallArgumentSyntax
ParsedSyntaxRecorder::deferFunctionCallArgument(Optional<ParsedTokenSyntax> Label, Optional<ParsedTokenSyntax> Colon, ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionCallArgument, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.hasValue() ? Label->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedFunctionCallArgumentSyntax(std::move(raw));
}

ParsedFunctionCallArgumentSyntax
ParsedSyntaxRecorder::makeFunctionCallArgument(Optional<ParsedTokenSyntax> Label, Optional<ParsedTokenSyntax> Colon, ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFunctionCallArgument(std::move(Label), std::move(Colon), std::move(Expression), std::move(TrailingComma), SPCtx);
  return recordFunctionCallArgument(std::move(Label), std::move(Colon), std::move(Expression), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTupleElementSyntax
ParsedSyntaxRecorder::recordTupleElement(Optional<ParsedTokenSyntax> Label, Optional<ParsedTokenSyntax> Colon, ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TupleElement, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.hasValue() ? Label->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTupleElementSyntax(std::move(raw));
}

ParsedTupleElementSyntax
ParsedSyntaxRecorder::deferTupleElement(Optional<ParsedTokenSyntax> Label, Optional<ParsedTokenSyntax> Colon, ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TupleElement, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.hasValue() ? Label->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTupleElementSyntax(std::move(raw));
}

ParsedTupleElementSyntax
ParsedSyntaxRecorder::makeTupleElement(Optional<ParsedTokenSyntax> Label, Optional<ParsedTokenSyntax> Colon, ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTupleElement(std::move(Label), std::move(Colon), std::move(Expression), std::move(TrailingComma), SPCtx);
  return recordTupleElement(std::move(Label), std::move(Colon), std::move(Expression), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedArrayElementSyntax
ParsedSyntaxRecorder::recordArrayElement(ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ArrayElement, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedArrayElementSyntax(std::move(raw));
}

ParsedArrayElementSyntax
ParsedSyntaxRecorder::deferArrayElement(ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ArrayElement, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedArrayElementSyntax(std::move(raw));
}

ParsedArrayElementSyntax
ParsedSyntaxRecorder::makeArrayElement(ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferArrayElement(std::move(Expression), std::move(TrailingComma), SPCtx);
  return recordArrayElement(std::move(Expression), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDictionaryElementSyntax
ParsedSyntaxRecorder::recordDictionaryElement(ParsedExprSyntax KeyExpression, ParsedTokenSyntax Colon, ParsedExprSyntax ValueExpression, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DictionaryElement, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    KeyExpression.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ValueExpression.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDictionaryElementSyntax(std::move(raw));
}

ParsedDictionaryElementSyntax
ParsedSyntaxRecorder::deferDictionaryElement(ParsedExprSyntax KeyExpression, ParsedTokenSyntax Colon, ParsedExprSyntax ValueExpression, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DictionaryElement, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    KeyExpression.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ValueExpression.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDictionaryElementSyntax(std::move(raw));
}

ParsedDictionaryElementSyntax
ParsedSyntaxRecorder::makeDictionaryElement(ParsedExprSyntax KeyExpression, ParsedTokenSyntax Colon, ParsedExprSyntax ValueExpression, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDictionaryElement(std::move(KeyExpression), std::move(Colon), std::move(ValueExpression), std::move(TrailingComma), SPCtx);
  return recordDictionaryElement(std::move(KeyExpression), std::move(Colon), std::move(ValueExpression), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIntegerLiteralExprSyntax
ParsedSyntaxRecorder::recordIntegerLiteralExpr(ParsedTokenSyntax Digits,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::IntegerLiteralExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Digits.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedIntegerLiteralExprSyntax(std::move(raw));
}

ParsedIntegerLiteralExprSyntax
ParsedSyntaxRecorder::deferIntegerLiteralExpr(ParsedTokenSyntax Digits, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IntegerLiteralExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Digits.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedIntegerLiteralExprSyntax(std::move(raw));
}

ParsedIntegerLiteralExprSyntax
ParsedSyntaxRecorder::makeIntegerLiteralExpr(ParsedTokenSyntax Digits,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIntegerLiteralExpr(std::move(Digits), SPCtx);
  return recordIntegerLiteralExpr(std::move(Digits), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedBooleanLiteralExprSyntax
ParsedSyntaxRecorder::recordBooleanLiteralExpr(ParsedTokenSyntax BooleanLiteral,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::BooleanLiteralExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BooleanLiteral.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedBooleanLiteralExprSyntax(std::move(raw));
}

ParsedBooleanLiteralExprSyntax
ParsedSyntaxRecorder::deferBooleanLiteralExpr(ParsedTokenSyntax BooleanLiteral, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::BooleanLiteralExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BooleanLiteral.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedBooleanLiteralExprSyntax(std::move(raw));
}

ParsedBooleanLiteralExprSyntax
ParsedSyntaxRecorder::makeBooleanLiteralExpr(ParsedTokenSyntax BooleanLiteral,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferBooleanLiteralExpr(std::move(BooleanLiteral), SPCtx);
  return recordBooleanLiteralExpr(std::move(BooleanLiteral), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTernaryExprSyntax
ParsedSyntaxRecorder::recordTernaryExpr(ParsedExprSyntax ConditionExpression, ParsedTokenSyntax QuestionMark, ParsedExprSyntax FirstChoice, ParsedTokenSyntax ColonMark, ParsedExprSyntax SecondChoice,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TernaryExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ConditionExpression.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionMark.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FirstChoice.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ColonMark.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SecondChoice.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTernaryExprSyntax(std::move(raw));
}

ParsedTernaryExprSyntax
ParsedSyntaxRecorder::deferTernaryExpr(ParsedExprSyntax ConditionExpression, ParsedTokenSyntax QuestionMark, ParsedExprSyntax FirstChoice, ParsedTokenSyntax ColonMark, ParsedExprSyntax SecondChoice, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TernaryExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ConditionExpression.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionMark.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FirstChoice.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ColonMark.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SecondChoice.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTernaryExprSyntax(std::move(raw));
}

ParsedTernaryExprSyntax
ParsedSyntaxRecorder::makeTernaryExpr(ParsedExprSyntax ConditionExpression, ParsedTokenSyntax QuestionMark, ParsedExprSyntax FirstChoice, ParsedTokenSyntax ColonMark, ParsedExprSyntax SecondChoice,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTernaryExpr(std::move(ConditionExpression), std::move(QuestionMark), std::move(FirstChoice), std::move(ColonMark), std::move(SecondChoice), SPCtx);
  return recordTernaryExpr(std::move(ConditionExpression), std::move(QuestionMark), std::move(FirstChoice), std::move(ColonMark), std::move(SecondChoice), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedMemberAccessExprSyntax
ParsedSyntaxRecorder::recordMemberAccessExpr(Optional<ParsedExprSyntax> Base, ParsedTokenSyntax Dot, ParsedTokenSyntax Name, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::MemberAccessExpr, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Base.hasValue() ? Base->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Dot.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclNameArguments.hasValue() ? DeclNameArguments->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedMemberAccessExprSyntax(std::move(raw));
}

ParsedMemberAccessExprSyntax
ParsedSyntaxRecorder::deferMemberAccessExpr(Optional<ParsedExprSyntax> Base, ParsedTokenSyntax Dot, ParsedTokenSyntax Name, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::MemberAccessExpr, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Base.hasValue() ? Base->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Dot.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclNameArguments.hasValue() ? DeclNameArguments->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedMemberAccessExprSyntax(std::move(raw));
}

ParsedMemberAccessExprSyntax
ParsedSyntaxRecorder::makeMemberAccessExpr(Optional<ParsedExprSyntax> Base, ParsedTokenSyntax Dot, ParsedTokenSyntax Name, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferMemberAccessExpr(std::move(Base), std::move(Dot), std::move(Name), std::move(DeclNameArguments), SPCtx);
  return recordMemberAccessExpr(std::move(Base), std::move(Dot), std::move(Name), std::move(DeclNameArguments), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIsExprSyntax
ParsedSyntaxRecorder::recordIsExpr(ParsedTokenSyntax IsTok, ParsedTypeSyntax TypeName,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::IsExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    IsTok.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeName.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedIsExprSyntax(std::move(raw));
}

ParsedIsExprSyntax
ParsedSyntaxRecorder::deferIsExpr(ParsedTokenSyntax IsTok, ParsedTypeSyntax TypeName, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IsExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    IsTok.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeName.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedIsExprSyntax(std::move(raw));
}

ParsedIsExprSyntax
ParsedSyntaxRecorder::makeIsExpr(ParsedTokenSyntax IsTok, ParsedTypeSyntax TypeName,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIsExpr(std::move(IsTok), std::move(TypeName), SPCtx);
  return recordIsExpr(std::move(IsTok), std::move(TypeName), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAsExprSyntax
ParsedSyntaxRecorder::recordAsExpr(ParsedTokenSyntax AsTok, Optional<ParsedTokenSyntax> QuestionOrExclamationMark, ParsedTypeSyntax TypeName,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AsExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AsTok.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionOrExclamationMark.hasValue() ? QuestionOrExclamationMark->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeName.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAsExprSyntax(std::move(raw));
}

ParsedAsExprSyntax
ParsedSyntaxRecorder::deferAsExpr(ParsedTokenSyntax AsTok, Optional<ParsedTokenSyntax> QuestionOrExclamationMark, ParsedTypeSyntax TypeName, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AsExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AsTok.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionOrExclamationMark.hasValue() ? QuestionOrExclamationMark->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeName.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAsExprSyntax(std::move(raw));
}

ParsedAsExprSyntax
ParsedSyntaxRecorder::makeAsExpr(ParsedTokenSyntax AsTok, Optional<ParsedTokenSyntax> QuestionOrExclamationMark, ParsedTypeSyntax TypeName,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAsExpr(std::move(AsTok), std::move(QuestionOrExclamationMark), std::move(TypeName), SPCtx);
  return recordAsExpr(std::move(AsTok), std::move(QuestionOrExclamationMark), std::move(TypeName), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTypeExprSyntax
ParsedSyntaxRecorder::recordTypeExpr(ParsedTypeSyntax Type,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TypeExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTypeExprSyntax(std::move(raw));
}

ParsedTypeExprSyntax
ParsedSyntaxRecorder::deferTypeExpr(ParsedTypeSyntax Type, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TypeExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTypeExprSyntax(std::move(raw));
}

ParsedTypeExprSyntax
ParsedSyntaxRecorder::makeTypeExpr(ParsedTypeSyntax Type,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTypeExpr(std::move(Type), SPCtx);
  return recordTypeExpr(std::move(Type), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedClosureCaptureItemSyntax
ParsedSyntaxRecorder::recordClosureCaptureItem(Optional<ParsedTokenListSyntax> Specifier, Optional<ParsedTokenSyntax> Name, Optional<ParsedTokenSyntax> AssignToken, ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ClosureCaptureItem, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Specifier.hasValue() ? Specifier->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.hasValue() ? Name->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssignToken.hasValue() ? AssignToken->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedClosureCaptureItemSyntax(std::move(raw));
}

ParsedClosureCaptureItemSyntax
ParsedSyntaxRecorder::deferClosureCaptureItem(Optional<ParsedTokenListSyntax> Specifier, Optional<ParsedTokenSyntax> Name, Optional<ParsedTokenSyntax> AssignToken, ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClosureCaptureItem, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Specifier.hasValue() ? Specifier->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.hasValue() ? Name->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssignToken.hasValue() ? AssignToken->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedClosureCaptureItemSyntax(std::move(raw));
}

ParsedClosureCaptureItemSyntax
ParsedSyntaxRecorder::makeClosureCaptureItem(Optional<ParsedTokenListSyntax> Specifier, Optional<ParsedTokenSyntax> Name, Optional<ParsedTokenSyntax> AssignToken, ParsedExprSyntax Expression, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferClosureCaptureItem(std::move(Specifier), std::move(Name), std::move(AssignToken), std::move(Expression), std::move(TrailingComma), SPCtx);
  return recordClosureCaptureItem(std::move(Specifier), std::move(Name), std::move(AssignToken), std::move(Expression), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedClosureCaptureItemListSyntax
ParsedSyntaxRecorder::recordClosureCaptureItemList(
    ArrayRef<ParsedClosureCaptureItemSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::ClosureCaptureItemList, layout);
  return ParsedClosureCaptureItemListSyntax(std::move(raw));
}

ParsedClosureCaptureItemListSyntax
ParsedSyntaxRecorder::deferClosureCaptureItemList(
    ArrayRef<ParsedClosureCaptureItemSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClosureCaptureItemList,
                             layout, SPCtx);
  return ParsedClosureCaptureItemListSyntax(std::move(raw));
}

ParsedClosureCaptureItemListSyntax
ParsedSyntaxRecorder::makeClosureCaptureItemList(
    ArrayRef<ParsedClosureCaptureItemSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferClosureCaptureItemList(elements, SPCtx);
  return recordClosureCaptureItemList(elements, SPCtx.getRecorder());
}

ParsedClosureCaptureItemListSyntax
ParsedSyntaxRecorder::makeBlankClosureCaptureItemList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClosureCaptureItemList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::ClosureCaptureItemList, loc);
  }
  return ParsedClosureCaptureItemListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedClosureCaptureSignatureSyntax
ParsedSyntaxRecorder::recordClosureCaptureSignature(ParsedTokenSyntax LeftSquare, Optional<ParsedClosureCaptureItemListSyntax> Items, ParsedTokenSyntax RightSquare,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ClosureCaptureSignature, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquare.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Items.hasValue() ? Items->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquare.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedClosureCaptureSignatureSyntax(std::move(raw));
}

ParsedClosureCaptureSignatureSyntax
ParsedSyntaxRecorder::deferClosureCaptureSignature(ParsedTokenSyntax LeftSquare, Optional<ParsedClosureCaptureItemListSyntax> Items, ParsedTokenSyntax RightSquare, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClosureCaptureSignature, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquare.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Items.hasValue() ? Items->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquare.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedClosureCaptureSignatureSyntax(std::move(raw));
}

ParsedClosureCaptureSignatureSyntax
ParsedSyntaxRecorder::makeClosureCaptureSignature(ParsedTokenSyntax LeftSquare, Optional<ParsedClosureCaptureItemListSyntax> Items, ParsedTokenSyntax RightSquare,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferClosureCaptureSignature(std::move(LeftSquare), std::move(Items), std::move(RightSquare), SPCtx);
  return recordClosureCaptureSignature(std::move(LeftSquare), std::move(Items), std::move(RightSquare), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedClosureParamSyntax
ParsedSyntaxRecorder::recordClosureParam(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ClosureParam, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedClosureParamSyntax(std::move(raw));
}

ParsedClosureParamSyntax
ParsedSyntaxRecorder::deferClosureParam(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClosureParam, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedClosureParamSyntax(std::move(raw));
}

ParsedClosureParamSyntax
ParsedSyntaxRecorder::makeClosureParam(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferClosureParam(std::move(Name), std::move(TrailingComma), SPCtx);
  return recordClosureParam(std::move(Name), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedClosureParamListSyntax
ParsedSyntaxRecorder::recordClosureParamList(
    ArrayRef<ParsedClosureParamSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::ClosureParamList, layout);
  return ParsedClosureParamListSyntax(std::move(raw));
}

ParsedClosureParamListSyntax
ParsedSyntaxRecorder::deferClosureParamList(
    ArrayRef<ParsedClosureParamSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClosureParamList,
                             layout, SPCtx);
  return ParsedClosureParamListSyntax(std::move(raw));
}

ParsedClosureParamListSyntax
ParsedSyntaxRecorder::makeClosureParamList(
    ArrayRef<ParsedClosureParamSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferClosureParamList(elements, SPCtx);
  return recordClosureParamList(elements, SPCtx.getRecorder());
}

ParsedClosureParamListSyntax
ParsedSyntaxRecorder::makeBlankClosureParamList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClosureParamList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::ClosureParamList, loc);
  }
  return ParsedClosureParamListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedClosureSignatureSyntax
ParsedSyntaxRecorder::recordClosureSignature(Optional<ParsedClosureCaptureSignatureSyntax> Capture, Optional<ParsedSyntax> Input, Optional<ParsedTokenSyntax> ThrowsTok, Optional<ParsedReturnClauseSyntax> Output, ParsedTokenSyntax InTok,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ClosureSignature, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Capture.hasValue() ? Capture->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Input.hasValue() ? Input->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsTok.hasValue() ? ThrowsTok->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Output.hasValue() ? Output->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InTok.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedClosureSignatureSyntax(std::move(raw));
}

ParsedClosureSignatureSyntax
ParsedSyntaxRecorder::deferClosureSignature(Optional<ParsedClosureCaptureSignatureSyntax> Capture, Optional<ParsedSyntax> Input, Optional<ParsedTokenSyntax> ThrowsTok, Optional<ParsedReturnClauseSyntax> Output, ParsedTokenSyntax InTok, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClosureSignature, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Capture.hasValue() ? Capture->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Input.hasValue() ? Input->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsTok.hasValue() ? ThrowsTok->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Output.hasValue() ? Output->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InTok.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedClosureSignatureSyntax(std::move(raw));
}

ParsedClosureSignatureSyntax
ParsedSyntaxRecorder::makeClosureSignature(Optional<ParsedClosureCaptureSignatureSyntax> Capture, Optional<ParsedSyntax> Input, Optional<ParsedTokenSyntax> ThrowsTok, Optional<ParsedReturnClauseSyntax> Output, ParsedTokenSyntax InTok,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferClosureSignature(std::move(Capture), std::move(Input), std::move(ThrowsTok), std::move(Output), std::move(InTok), SPCtx);
  return recordClosureSignature(std::move(Capture), std::move(Input), std::move(ThrowsTok), std::move(Output), std::move(InTok), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedClosureExprSyntax
ParsedSyntaxRecorder::recordClosureExpr(ParsedTokenSyntax LeftBrace, Optional<ParsedClosureSignatureSyntax> Signature, ParsedCodeBlockItemListSyntax Statements, ParsedTokenSyntax RightBrace,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ClosureExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Signature.hasValue() ? Signature->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Statements.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedClosureExprSyntax(std::move(raw));
}

ParsedClosureExprSyntax
ParsedSyntaxRecorder::deferClosureExpr(ParsedTokenSyntax LeftBrace, Optional<ParsedClosureSignatureSyntax> Signature, ParsedCodeBlockItemListSyntax Statements, ParsedTokenSyntax RightBrace, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClosureExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Signature.hasValue() ? Signature->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Statements.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedClosureExprSyntax(std::move(raw));
}

ParsedClosureExprSyntax
ParsedSyntaxRecorder::makeClosureExpr(ParsedTokenSyntax LeftBrace, Optional<ParsedClosureSignatureSyntax> Signature, ParsedCodeBlockItemListSyntax Statements, ParsedTokenSyntax RightBrace,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferClosureExpr(std::move(LeftBrace), std::move(Signature), std::move(Statements), std::move(RightBrace), SPCtx);
  return recordClosureExpr(std::move(LeftBrace), std::move(Signature), std::move(Statements), std::move(RightBrace), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedUnresolvedPatternExprSyntax
ParsedSyntaxRecorder::recordUnresolvedPatternExpr(ParsedPatternSyntax Pattern,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::UnresolvedPatternExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedUnresolvedPatternExprSyntax(std::move(raw));
}

ParsedUnresolvedPatternExprSyntax
ParsedSyntaxRecorder::deferUnresolvedPatternExpr(ParsedPatternSyntax Pattern, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::UnresolvedPatternExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedUnresolvedPatternExprSyntax(std::move(raw));
}

ParsedUnresolvedPatternExprSyntax
ParsedSyntaxRecorder::makeUnresolvedPatternExpr(ParsedPatternSyntax Pattern,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferUnresolvedPatternExpr(std::move(Pattern), SPCtx);
  return recordUnresolvedPatternExpr(std::move(Pattern), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFunctionCallExprSyntax
ParsedSyntaxRecorder::recordFunctionCallExpr(ParsedExprSyntax CalledExpression, Optional<ParsedTokenSyntax> LeftParen, ParsedFunctionCallArgumentListSyntax ArgumentList, Optional<ParsedTokenSyntax> RightParen, Optional<ParsedClosureExprSyntax> TrailingClosure,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::FunctionCallExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CalledExpression.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.hasValue() ? LeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArgumentList.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.hasValue() ? RightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingClosure.hasValue() ? TrailingClosure->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedFunctionCallExprSyntax(std::move(raw));
}

ParsedFunctionCallExprSyntax
ParsedSyntaxRecorder::deferFunctionCallExpr(ParsedExprSyntax CalledExpression, Optional<ParsedTokenSyntax> LeftParen, ParsedFunctionCallArgumentListSyntax ArgumentList, Optional<ParsedTokenSyntax> RightParen, Optional<ParsedClosureExprSyntax> TrailingClosure, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionCallExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CalledExpression.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.hasValue() ? LeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArgumentList.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.hasValue() ? RightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingClosure.hasValue() ? TrailingClosure->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedFunctionCallExprSyntax(std::move(raw));
}

ParsedFunctionCallExprSyntax
ParsedSyntaxRecorder::makeFunctionCallExpr(ParsedExprSyntax CalledExpression, Optional<ParsedTokenSyntax> LeftParen, ParsedFunctionCallArgumentListSyntax ArgumentList, Optional<ParsedTokenSyntax> RightParen, Optional<ParsedClosureExprSyntax> TrailingClosure,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFunctionCallExpr(std::move(CalledExpression), std::move(LeftParen), std::move(ArgumentList), std::move(RightParen), std::move(TrailingClosure), SPCtx);
  return recordFunctionCallExpr(std::move(CalledExpression), std::move(LeftParen), std::move(ArgumentList), std::move(RightParen), std::move(TrailingClosure), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSubscriptExprSyntax
ParsedSyntaxRecorder::recordSubscriptExpr(ParsedExprSyntax CalledExpression, ParsedTokenSyntax LeftBracket, ParsedFunctionCallArgumentListSyntax ArgumentList, ParsedTokenSyntax RightBracket, Optional<ParsedClosureExprSyntax> TrailingClosure,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SubscriptExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CalledExpression.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBracket.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArgumentList.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBracket.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingClosure.hasValue() ? TrailingClosure->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSubscriptExprSyntax(std::move(raw));
}

ParsedSubscriptExprSyntax
ParsedSyntaxRecorder::deferSubscriptExpr(ParsedExprSyntax CalledExpression, ParsedTokenSyntax LeftBracket, ParsedFunctionCallArgumentListSyntax ArgumentList, ParsedTokenSyntax RightBracket, Optional<ParsedClosureExprSyntax> TrailingClosure, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SubscriptExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CalledExpression.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBracket.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArgumentList.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBracket.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingClosure.hasValue() ? TrailingClosure->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSubscriptExprSyntax(std::move(raw));
}

ParsedSubscriptExprSyntax
ParsedSyntaxRecorder::makeSubscriptExpr(ParsedExprSyntax CalledExpression, ParsedTokenSyntax LeftBracket, ParsedFunctionCallArgumentListSyntax ArgumentList, ParsedTokenSyntax RightBracket, Optional<ParsedClosureExprSyntax> TrailingClosure,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSubscriptExpr(std::move(CalledExpression), std::move(LeftBracket), std::move(ArgumentList), std::move(RightBracket), std::move(TrailingClosure), SPCtx);
  return recordSubscriptExpr(std::move(CalledExpression), std::move(LeftBracket), std::move(ArgumentList), std::move(RightBracket), std::move(TrailingClosure), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedOptionalChainingExprSyntax
ParsedSyntaxRecorder::recordOptionalChainingExpr(ParsedExprSyntax Expression, ParsedTokenSyntax QuestionMark,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::OptionalChainingExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionMark.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedOptionalChainingExprSyntax(std::move(raw));
}

ParsedOptionalChainingExprSyntax
ParsedSyntaxRecorder::deferOptionalChainingExpr(ParsedExprSyntax Expression, ParsedTokenSyntax QuestionMark, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::OptionalChainingExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionMark.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedOptionalChainingExprSyntax(std::move(raw));
}

ParsedOptionalChainingExprSyntax
ParsedSyntaxRecorder::makeOptionalChainingExpr(ParsedExprSyntax Expression, ParsedTokenSyntax QuestionMark,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferOptionalChainingExpr(std::move(Expression), std::move(QuestionMark), SPCtx);
  return recordOptionalChainingExpr(std::move(Expression), std::move(QuestionMark), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedForcedValueExprSyntax
ParsedSyntaxRecorder::recordForcedValueExpr(ParsedExprSyntax Expression, ParsedTokenSyntax ExclamationMark,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ForcedValueExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ExclamationMark.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedForcedValueExprSyntax(std::move(raw));
}

ParsedForcedValueExprSyntax
ParsedSyntaxRecorder::deferForcedValueExpr(ParsedExprSyntax Expression, ParsedTokenSyntax ExclamationMark, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ForcedValueExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ExclamationMark.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedForcedValueExprSyntax(std::move(raw));
}

ParsedForcedValueExprSyntax
ParsedSyntaxRecorder::makeForcedValueExpr(ParsedExprSyntax Expression, ParsedTokenSyntax ExclamationMark,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferForcedValueExpr(std::move(Expression), std::move(ExclamationMark), SPCtx);
  return recordForcedValueExpr(std::move(Expression), std::move(ExclamationMark), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPostfixUnaryExprSyntax
ParsedSyntaxRecorder::recordPostfixUnaryExpr(ParsedExprSyntax Expression, ParsedTokenSyntax OperatorToken,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PostfixUnaryExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorToken.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPostfixUnaryExprSyntax(std::move(raw));
}

ParsedPostfixUnaryExprSyntax
ParsedSyntaxRecorder::deferPostfixUnaryExpr(ParsedExprSyntax Expression, ParsedTokenSyntax OperatorToken, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PostfixUnaryExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorToken.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPostfixUnaryExprSyntax(std::move(raw));
}

ParsedPostfixUnaryExprSyntax
ParsedSyntaxRecorder::makePostfixUnaryExpr(ParsedExprSyntax Expression, ParsedTokenSyntax OperatorToken,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPostfixUnaryExpr(std::move(Expression), std::move(OperatorToken), SPCtx);
  return recordPostfixUnaryExpr(std::move(Expression), std::move(OperatorToken), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSpecializeExprSyntax
ParsedSyntaxRecorder::recordSpecializeExpr(ParsedExprSyntax Expression, ParsedGenericArgumentClauseSyntax GenericArgumentClause,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SpecializeExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericArgumentClause.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSpecializeExprSyntax(std::move(raw));
}

ParsedSpecializeExprSyntax
ParsedSyntaxRecorder::deferSpecializeExpr(ParsedExprSyntax Expression, ParsedGenericArgumentClauseSyntax GenericArgumentClause, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SpecializeExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericArgumentClause.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSpecializeExprSyntax(std::move(raw));
}

ParsedSpecializeExprSyntax
ParsedSyntaxRecorder::makeSpecializeExpr(ParsedExprSyntax Expression, ParsedGenericArgumentClauseSyntax GenericArgumentClause,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSpecializeExpr(std::move(Expression), std::move(GenericArgumentClause), SPCtx);
  return recordSpecializeExpr(std::move(Expression), std::move(GenericArgumentClause), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedStringSegmentSyntax
ParsedSyntaxRecorder::recordStringSegment(ParsedTokenSyntax Content,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::StringSegment, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Content.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedStringSegmentSyntax(std::move(raw));
}

ParsedStringSegmentSyntax
ParsedSyntaxRecorder::deferStringSegment(ParsedTokenSyntax Content, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::StringSegment, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Content.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedStringSegmentSyntax(std::move(raw));
}

ParsedStringSegmentSyntax
ParsedSyntaxRecorder::makeStringSegment(ParsedTokenSyntax Content,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferStringSegment(std::move(Content), SPCtx);
  return recordStringSegment(std::move(Content), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedExpressionSegmentSyntax
ParsedSyntaxRecorder::recordExpressionSegment(ParsedTokenSyntax Backslash, Optional<ParsedTokenSyntax> Delimiter, ParsedTokenSyntax LeftParen, ParsedFunctionCallArgumentListSyntax Expressions, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ExpressionSegment, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Backslash.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Delimiter.hasValue() ? Delimiter->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expressions.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedExpressionSegmentSyntax(std::move(raw));
}

ParsedExpressionSegmentSyntax
ParsedSyntaxRecorder::deferExpressionSegment(ParsedTokenSyntax Backslash, Optional<ParsedTokenSyntax> Delimiter, ParsedTokenSyntax LeftParen, ParsedFunctionCallArgumentListSyntax Expressions, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ExpressionSegment, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Backslash.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Delimiter.hasValue() ? Delimiter->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expressions.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedExpressionSegmentSyntax(std::move(raw));
}

ParsedExpressionSegmentSyntax
ParsedSyntaxRecorder::makeExpressionSegment(ParsedTokenSyntax Backslash, Optional<ParsedTokenSyntax> Delimiter, ParsedTokenSyntax LeftParen, ParsedFunctionCallArgumentListSyntax Expressions, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferExpressionSegment(std::move(Backslash), std::move(Delimiter), std::move(LeftParen), std::move(Expressions), std::move(RightParen), SPCtx);
  return recordExpressionSegment(std::move(Backslash), std::move(Delimiter), std::move(LeftParen), std::move(Expressions), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedStringLiteralExprSyntax
ParsedSyntaxRecorder::recordStringLiteralExpr(Optional<ParsedTokenSyntax> OpenDelimiter, ParsedTokenSyntax OpenQuote, ParsedStringLiteralSegmentsSyntax Segments, ParsedTokenSyntax CloseQuote, Optional<ParsedTokenSyntax> CloseDelimiter,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::StringLiteralExpr, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OpenDelimiter.hasValue() ? OpenDelimiter->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OpenQuote.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Segments.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CloseQuote.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CloseDelimiter.hasValue() ? CloseDelimiter->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedStringLiteralExprSyntax(std::move(raw));
}

ParsedStringLiteralExprSyntax
ParsedSyntaxRecorder::deferStringLiteralExpr(Optional<ParsedTokenSyntax> OpenDelimiter, ParsedTokenSyntax OpenQuote, ParsedStringLiteralSegmentsSyntax Segments, ParsedTokenSyntax CloseQuote, Optional<ParsedTokenSyntax> CloseDelimiter, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::StringLiteralExpr, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OpenDelimiter.hasValue() ? OpenDelimiter->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OpenQuote.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Segments.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CloseQuote.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CloseDelimiter.hasValue() ? CloseDelimiter->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedStringLiteralExprSyntax(std::move(raw));
}

ParsedStringLiteralExprSyntax
ParsedSyntaxRecorder::makeStringLiteralExpr(Optional<ParsedTokenSyntax> OpenDelimiter, ParsedTokenSyntax OpenQuote, ParsedStringLiteralSegmentsSyntax Segments, ParsedTokenSyntax CloseQuote, Optional<ParsedTokenSyntax> CloseDelimiter,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferStringLiteralExpr(std::move(OpenDelimiter), std::move(OpenQuote), std::move(Segments), std::move(CloseQuote), std::move(CloseDelimiter), SPCtx);
  return recordStringLiteralExpr(std::move(OpenDelimiter), std::move(OpenQuote), std::move(Segments), std::move(CloseQuote), std::move(CloseDelimiter), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedKeyPathExprSyntax
ParsedSyntaxRecorder::recordKeyPathExpr(ParsedTokenSyntax Backslash, Optional<ParsedExprSyntax> RootExpr, ParsedExprSyntax Expression,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::KeyPathExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Backslash.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RootExpr.hasValue() ? RootExpr->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedKeyPathExprSyntax(std::move(raw));
}

ParsedKeyPathExprSyntax
ParsedSyntaxRecorder::deferKeyPathExpr(ParsedTokenSyntax Backslash, Optional<ParsedExprSyntax> RootExpr, ParsedExprSyntax Expression, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::KeyPathExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Backslash.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RootExpr.hasValue() ? RootExpr->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedKeyPathExprSyntax(std::move(raw));
}

ParsedKeyPathExprSyntax
ParsedSyntaxRecorder::makeKeyPathExpr(ParsedTokenSyntax Backslash, Optional<ParsedExprSyntax> RootExpr, ParsedExprSyntax Expression,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferKeyPathExpr(std::move(Backslash), std::move(RootExpr), std::move(Expression), SPCtx);
  return recordKeyPathExpr(std::move(Backslash), std::move(RootExpr), std::move(Expression), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedKeyPathBaseExprSyntax
ParsedSyntaxRecorder::recordKeyPathBaseExpr(ParsedTokenSyntax Period,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::KeyPathBaseExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Period.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedKeyPathBaseExprSyntax(std::move(raw));
}

ParsedKeyPathBaseExprSyntax
ParsedSyntaxRecorder::deferKeyPathBaseExpr(ParsedTokenSyntax Period, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::KeyPathBaseExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Period.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedKeyPathBaseExprSyntax(std::move(raw));
}

ParsedKeyPathBaseExprSyntax
ParsedSyntaxRecorder::makeKeyPathBaseExpr(ParsedTokenSyntax Period,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferKeyPathBaseExpr(std::move(Period), SPCtx);
  return recordKeyPathBaseExpr(std::move(Period), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedObjcNamePieceSyntax
ParsedSyntaxRecorder::recordObjcNamePiece(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> Dot,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ObjcNamePiece, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Dot.hasValue() ? Dot->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedObjcNamePieceSyntax(std::move(raw));
}

ParsedObjcNamePieceSyntax
ParsedSyntaxRecorder::deferObjcNamePiece(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> Dot, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ObjcNamePiece, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Dot.hasValue() ? Dot->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedObjcNamePieceSyntax(std::move(raw));
}

ParsedObjcNamePieceSyntax
ParsedSyntaxRecorder::makeObjcNamePiece(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> Dot,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferObjcNamePiece(std::move(Name), std::move(Dot), SPCtx);
  return recordObjcNamePiece(std::move(Name), std::move(Dot), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedObjcNameSyntax
ParsedSyntaxRecorder::recordObjcName(
    ArrayRef<ParsedObjcNamePieceSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::ObjcName, layout);
  return ParsedObjcNameSyntax(std::move(raw));
}

ParsedObjcNameSyntax
ParsedSyntaxRecorder::deferObjcName(
    ArrayRef<ParsedObjcNamePieceSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ObjcName,
                             layout, SPCtx);
  return ParsedObjcNameSyntax(std::move(raw));
}

ParsedObjcNameSyntax
ParsedSyntaxRecorder::makeObjcName(
    ArrayRef<ParsedObjcNamePieceSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferObjcName(elements, SPCtx);
  return recordObjcName(elements, SPCtx.getRecorder());
}

ParsedObjcNameSyntax
ParsedSyntaxRecorder::makeBlankObjcName(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ObjcName, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::ObjcName, loc);
  }
  return ParsedObjcNameSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedObjcKeyPathExprSyntax
ParsedSyntaxRecorder::recordObjcKeyPathExpr(ParsedTokenSyntax KeyPath, ParsedTokenSyntax LeftParen, ParsedObjcNameSyntax Name, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ObjcKeyPathExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    KeyPath.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedObjcKeyPathExprSyntax(std::move(raw));
}

ParsedObjcKeyPathExprSyntax
ParsedSyntaxRecorder::deferObjcKeyPathExpr(ParsedTokenSyntax KeyPath, ParsedTokenSyntax LeftParen, ParsedObjcNameSyntax Name, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ObjcKeyPathExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    KeyPath.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedObjcKeyPathExprSyntax(std::move(raw));
}

ParsedObjcKeyPathExprSyntax
ParsedSyntaxRecorder::makeObjcKeyPathExpr(ParsedTokenSyntax KeyPath, ParsedTokenSyntax LeftParen, ParsedObjcNameSyntax Name, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferObjcKeyPathExpr(std::move(KeyPath), std::move(LeftParen), std::move(Name), std::move(RightParen), SPCtx);
  return recordObjcKeyPathExpr(std::move(KeyPath), std::move(LeftParen), std::move(Name), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedObjcSelectorExprSyntax
ParsedSyntaxRecorder::recordObjcSelectorExpr(ParsedTokenSyntax PoundSelector, ParsedTokenSyntax LeftParen, Optional<ParsedTokenSyntax> Kind, Optional<ParsedTokenSyntax> Colon, ParsedExprSyntax Name, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ObjcSelectorExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundSelector.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Kind.hasValue() ? Kind->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedObjcSelectorExprSyntax(std::move(raw));
}

ParsedObjcSelectorExprSyntax
ParsedSyntaxRecorder::deferObjcSelectorExpr(ParsedTokenSyntax PoundSelector, ParsedTokenSyntax LeftParen, Optional<ParsedTokenSyntax> Kind, Optional<ParsedTokenSyntax> Colon, ParsedExprSyntax Name, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ObjcSelectorExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundSelector.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Kind.hasValue() ? Kind->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedObjcSelectorExprSyntax(std::move(raw));
}

ParsedObjcSelectorExprSyntax
ParsedSyntaxRecorder::makeObjcSelectorExpr(ParsedTokenSyntax PoundSelector, ParsedTokenSyntax LeftParen, Optional<ParsedTokenSyntax> Kind, Optional<ParsedTokenSyntax> Colon, ParsedExprSyntax Name, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferObjcSelectorExpr(std::move(PoundSelector), std::move(LeftParen), std::move(Kind), std::move(Colon), std::move(Name), std::move(RightParen), SPCtx);
  return recordObjcSelectorExpr(std::move(PoundSelector), std::move(LeftParen), std::move(Kind), std::move(Colon), std::move(Name), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedEditorPlaceholderExprSyntax
ParsedSyntaxRecorder::recordEditorPlaceholderExpr(ParsedTokenSyntax Identifier,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::EditorPlaceholderExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedEditorPlaceholderExprSyntax(std::move(raw));
}

ParsedEditorPlaceholderExprSyntax
ParsedSyntaxRecorder::deferEditorPlaceholderExpr(ParsedTokenSyntax Identifier, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::EditorPlaceholderExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedEditorPlaceholderExprSyntax(std::move(raw));
}

ParsedEditorPlaceholderExprSyntax
ParsedSyntaxRecorder::makeEditorPlaceholderExpr(ParsedTokenSyntax Identifier,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferEditorPlaceholderExpr(std::move(Identifier), SPCtx);
  return recordEditorPlaceholderExpr(std::move(Identifier), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedObjectLiteralExprSyntax
ParsedSyntaxRecorder::recordObjectLiteralExpr(ParsedTokenSyntax Identifier, ParsedTokenSyntax LeftParen, ParsedFunctionCallArgumentListSyntax Arguments, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ObjectLiteralExpr, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arguments.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedObjectLiteralExprSyntax(std::move(raw));
}

ParsedObjectLiteralExprSyntax
ParsedSyntaxRecorder::deferObjectLiteralExpr(ParsedTokenSyntax Identifier, ParsedTokenSyntax LeftParen, ParsedFunctionCallArgumentListSyntax Arguments, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ObjectLiteralExpr, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arguments.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedObjectLiteralExprSyntax(std::move(raw));
}

ParsedObjectLiteralExprSyntax
ParsedSyntaxRecorder::makeObjectLiteralExpr(ParsedTokenSyntax Identifier, ParsedTokenSyntax LeftParen, ParsedFunctionCallArgumentListSyntax Arguments, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferObjectLiteralExpr(std::move(Identifier), std::move(LeftParen), std::move(Arguments), std::move(RightParen), SPCtx);
  return recordObjectLiteralExpr(std::move(Identifier), std::move(LeftParen), std::move(Arguments), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTypeInitializerClauseSyntax
ParsedSyntaxRecorder::recordTypeInitializerClause(ParsedTokenSyntax Equal, ParsedTypeSyntax Value,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TypeInitializerClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Equal.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTypeInitializerClauseSyntax(std::move(raw));
}

ParsedTypeInitializerClauseSyntax
ParsedSyntaxRecorder::deferTypeInitializerClause(ParsedTokenSyntax Equal, ParsedTypeSyntax Value, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TypeInitializerClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Equal.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTypeInitializerClauseSyntax(std::move(raw));
}

ParsedTypeInitializerClauseSyntax
ParsedSyntaxRecorder::makeTypeInitializerClause(ParsedTokenSyntax Equal, ParsedTypeSyntax Value,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTypeInitializerClause(std::move(Equal), std::move(Value), SPCtx);
  return recordTypeInitializerClause(std::move(Equal), std::move(Value), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTypealiasDeclSyntax
ParsedSyntaxRecorder::recordTypealiasDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax TypealiasKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, Optional<ParsedTypeInitializerClauseSyntax> Initializer, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TypealiasDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypealiasKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.hasValue() ? Initializer->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTypealiasDeclSyntax(std::move(raw));
}

ParsedTypealiasDeclSyntax
ParsedSyntaxRecorder::deferTypealiasDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax TypealiasKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, Optional<ParsedTypeInitializerClauseSyntax> Initializer, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TypealiasDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypealiasKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.hasValue() ? Initializer->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTypealiasDeclSyntax(std::move(raw));
}

ParsedTypealiasDeclSyntax
ParsedSyntaxRecorder::makeTypealiasDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax TypealiasKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, Optional<ParsedTypeInitializerClauseSyntax> Initializer, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTypealiasDecl(std::move(Attributes), std::move(Modifiers), std::move(TypealiasKeyword), std::move(Identifier), std::move(GenericParameterClause), std::move(Initializer), std::move(GenericWhereClause), SPCtx);
  return recordTypealiasDecl(std::move(Attributes), std::move(Modifiers), std::move(TypealiasKeyword), std::move(Identifier), std::move(GenericParameterClause), std::move(Initializer), std::move(GenericWhereClause), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAssociatedtypeDeclSyntax
ParsedSyntaxRecorder::recordAssociatedtypeDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax AssociatedtypeKeyword, ParsedTokenSyntax Identifier, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedTypeInitializerClauseSyntax> Initializer, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AssociatedtypeDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssociatedtypeKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.hasValue() ? Initializer->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAssociatedtypeDeclSyntax(std::move(raw));
}

ParsedAssociatedtypeDeclSyntax
ParsedSyntaxRecorder::deferAssociatedtypeDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax AssociatedtypeKeyword, ParsedTokenSyntax Identifier, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedTypeInitializerClauseSyntax> Initializer, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AssociatedtypeDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssociatedtypeKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.hasValue() ? Initializer->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAssociatedtypeDeclSyntax(std::move(raw));
}

ParsedAssociatedtypeDeclSyntax
ParsedSyntaxRecorder::makeAssociatedtypeDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax AssociatedtypeKeyword, ParsedTokenSyntax Identifier, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedTypeInitializerClauseSyntax> Initializer, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAssociatedtypeDecl(std::move(Attributes), std::move(Modifiers), std::move(AssociatedtypeKeyword), std::move(Identifier), std::move(InheritanceClause), std::move(Initializer), std::move(GenericWhereClause), SPCtx);
  return recordAssociatedtypeDecl(std::move(Attributes), std::move(Modifiers), std::move(AssociatedtypeKeyword), std::move(Identifier), std::move(InheritanceClause), std::move(Initializer), std::move(GenericWhereClause), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFunctionParameterListSyntax
ParsedSyntaxRecorder::recordFunctionParameterList(
    ArrayRef<ParsedFunctionParameterSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::FunctionParameterList, layout);
  return ParsedFunctionParameterListSyntax(std::move(raw));
}

ParsedFunctionParameterListSyntax
ParsedSyntaxRecorder::deferFunctionParameterList(
    ArrayRef<ParsedFunctionParameterSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionParameterList,
                             layout, SPCtx);
  return ParsedFunctionParameterListSyntax(std::move(raw));
}

ParsedFunctionParameterListSyntax
ParsedSyntaxRecorder::makeFunctionParameterList(
    ArrayRef<ParsedFunctionParameterSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFunctionParameterList(elements, SPCtx);
  return recordFunctionParameterList(elements, SPCtx.getRecorder());
}

ParsedFunctionParameterListSyntax
ParsedSyntaxRecorder::makeBlankFunctionParameterList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionParameterList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::FunctionParameterList, loc);
  }
  return ParsedFunctionParameterListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedParameterClauseSyntax
ParsedSyntaxRecorder::recordParameterClause(ParsedTokenSyntax LeftParen, ParsedFunctionParameterListSyntax ParameterList, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ParameterClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParameterList.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedParameterClauseSyntax(std::move(raw));
}

ParsedParameterClauseSyntax
ParsedSyntaxRecorder::deferParameterClause(ParsedTokenSyntax LeftParen, ParsedFunctionParameterListSyntax ParameterList, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ParameterClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ParameterList.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedParameterClauseSyntax(std::move(raw));
}

ParsedParameterClauseSyntax
ParsedSyntaxRecorder::makeParameterClause(ParsedTokenSyntax LeftParen, ParsedFunctionParameterListSyntax ParameterList, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferParameterClause(std::move(LeftParen), std::move(ParameterList), std::move(RightParen), SPCtx);
  return recordParameterClause(std::move(LeftParen), std::move(ParameterList), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedReturnClauseSyntax
ParsedSyntaxRecorder::recordReturnClause(ParsedTokenSyntax Arrow, ParsedTypeSyntax ReturnType,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ReturnClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arrow.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ReturnType.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedReturnClauseSyntax(std::move(raw));
}

ParsedReturnClauseSyntax
ParsedSyntaxRecorder::deferReturnClause(ParsedTokenSyntax Arrow, ParsedTypeSyntax ReturnType, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ReturnClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arrow.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ReturnType.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedReturnClauseSyntax(std::move(raw));
}

ParsedReturnClauseSyntax
ParsedSyntaxRecorder::makeReturnClause(ParsedTokenSyntax Arrow, ParsedTypeSyntax ReturnType,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferReturnClause(std::move(Arrow), std::move(ReturnType), SPCtx);
  return recordReturnClause(std::move(Arrow), std::move(ReturnType), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFunctionSignatureSyntax
ParsedSyntaxRecorder::recordFunctionSignature(ParsedParameterClauseSyntax Input, Optional<ParsedTokenSyntax> ThrowsOrRethrowsKeyword, Optional<ParsedReturnClauseSyntax> Output,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::FunctionSignature, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Input.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsOrRethrowsKeyword.hasValue() ? ThrowsOrRethrowsKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Output.hasValue() ? Output->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedFunctionSignatureSyntax(std::move(raw));
}

ParsedFunctionSignatureSyntax
ParsedSyntaxRecorder::deferFunctionSignature(ParsedParameterClauseSyntax Input, Optional<ParsedTokenSyntax> ThrowsOrRethrowsKeyword, Optional<ParsedReturnClauseSyntax> Output, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionSignature, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Input.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsOrRethrowsKeyword.hasValue() ? ThrowsOrRethrowsKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Output.hasValue() ? Output->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedFunctionSignatureSyntax(std::move(raw));
}

ParsedFunctionSignatureSyntax
ParsedSyntaxRecorder::makeFunctionSignature(ParsedParameterClauseSyntax Input, Optional<ParsedTokenSyntax> ThrowsOrRethrowsKeyword, Optional<ParsedReturnClauseSyntax> Output,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFunctionSignature(std::move(Input), std::move(ThrowsOrRethrowsKeyword), std::move(Output), SPCtx);
  return recordFunctionSignature(std::move(Input), std::move(ThrowsOrRethrowsKeyword), std::move(Output), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIfConfigClauseSyntax
ParsedSyntaxRecorder::recordIfConfigClause(ParsedTokenSyntax PoundKeyword, Optional<ParsedExprSyntax> Condition, ParsedSyntax Elements,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::IfConfigClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundKeyword.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Condition.hasValue() ? Condition->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedIfConfigClauseSyntax(std::move(raw));
}

ParsedIfConfigClauseSyntax
ParsedSyntaxRecorder::deferIfConfigClause(ParsedTokenSyntax PoundKeyword, Optional<ParsedExprSyntax> Condition, ParsedSyntax Elements, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IfConfigClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundKeyword.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Condition.hasValue() ? Condition->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedIfConfigClauseSyntax(std::move(raw));
}

ParsedIfConfigClauseSyntax
ParsedSyntaxRecorder::makeIfConfigClause(ParsedTokenSyntax PoundKeyword, Optional<ParsedExprSyntax> Condition, ParsedSyntax Elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIfConfigClause(std::move(PoundKeyword), std::move(Condition), std::move(Elements), SPCtx);
  return recordIfConfigClause(std::move(PoundKeyword), std::move(Condition), std::move(Elements), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIfConfigClauseListSyntax
ParsedSyntaxRecorder::recordIfConfigClauseList(
    ArrayRef<ParsedIfConfigClauseSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::IfConfigClauseList, layout);
  return ParsedIfConfigClauseListSyntax(std::move(raw));
}

ParsedIfConfigClauseListSyntax
ParsedSyntaxRecorder::deferIfConfigClauseList(
    ArrayRef<ParsedIfConfigClauseSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IfConfigClauseList,
                             layout, SPCtx);
  return ParsedIfConfigClauseListSyntax(std::move(raw));
}

ParsedIfConfigClauseListSyntax
ParsedSyntaxRecorder::makeIfConfigClauseList(
    ArrayRef<ParsedIfConfigClauseSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIfConfigClauseList(elements, SPCtx);
  return recordIfConfigClauseList(elements, SPCtx.getRecorder());
}

ParsedIfConfigClauseListSyntax
ParsedSyntaxRecorder::makeBlankIfConfigClauseList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IfConfigClauseList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::IfConfigClauseList, loc);
  }
  return ParsedIfConfigClauseListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIfConfigDeclSyntax
ParsedSyntaxRecorder::recordIfConfigDecl(ParsedIfConfigClauseListSyntax Clauses, ParsedTokenSyntax PoundEndif,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::IfConfigDecl, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Clauses.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundEndif.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedIfConfigDeclSyntax(std::move(raw));
}

ParsedIfConfigDeclSyntax
ParsedSyntaxRecorder::deferIfConfigDecl(ParsedIfConfigClauseListSyntax Clauses, ParsedTokenSyntax PoundEndif, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IfConfigDecl, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Clauses.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundEndif.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedIfConfigDeclSyntax(std::move(raw));
}

ParsedIfConfigDeclSyntax
ParsedSyntaxRecorder::makeIfConfigDecl(ParsedIfConfigClauseListSyntax Clauses, ParsedTokenSyntax PoundEndif,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIfConfigDecl(std::move(Clauses), std::move(PoundEndif), SPCtx);
  return recordIfConfigDecl(std::move(Clauses), std::move(PoundEndif), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundErrorDeclSyntax
ParsedSyntaxRecorder::recordPoundErrorDecl(ParsedTokenSyntax PoundError, ParsedTokenSyntax LeftParen, ParsedStringLiteralExprSyntax Message, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundErrorDecl, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundError.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Message.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundErrorDeclSyntax(std::move(raw));
}

ParsedPoundErrorDeclSyntax
ParsedSyntaxRecorder::deferPoundErrorDecl(ParsedTokenSyntax PoundError, ParsedTokenSyntax LeftParen, ParsedStringLiteralExprSyntax Message, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundErrorDecl, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundError.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Message.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundErrorDeclSyntax(std::move(raw));
}

ParsedPoundErrorDeclSyntax
ParsedSyntaxRecorder::makePoundErrorDecl(ParsedTokenSyntax PoundError, ParsedTokenSyntax LeftParen, ParsedStringLiteralExprSyntax Message, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundErrorDecl(std::move(PoundError), std::move(LeftParen), std::move(Message), std::move(RightParen), SPCtx);
  return recordPoundErrorDecl(std::move(PoundError), std::move(LeftParen), std::move(Message), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundWarningDeclSyntax
ParsedSyntaxRecorder::recordPoundWarningDecl(ParsedTokenSyntax PoundWarning, ParsedTokenSyntax LeftParen, ParsedStringLiteralExprSyntax Message, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundWarningDecl, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundWarning.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Message.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundWarningDeclSyntax(std::move(raw));
}

ParsedPoundWarningDeclSyntax
ParsedSyntaxRecorder::deferPoundWarningDecl(ParsedTokenSyntax PoundWarning, ParsedTokenSyntax LeftParen, ParsedStringLiteralExprSyntax Message, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundWarningDecl, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundWarning.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Message.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundWarningDeclSyntax(std::move(raw));
}

ParsedPoundWarningDeclSyntax
ParsedSyntaxRecorder::makePoundWarningDecl(ParsedTokenSyntax PoundWarning, ParsedTokenSyntax LeftParen, ParsedStringLiteralExprSyntax Message, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundWarningDecl(std::move(PoundWarning), std::move(LeftParen), std::move(Message), std::move(RightParen), SPCtx);
  return recordPoundWarningDecl(std::move(PoundWarning), std::move(LeftParen), std::move(Message), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundSourceLocationSyntax
ParsedSyntaxRecorder::recordPoundSourceLocation(ParsedTokenSyntax PoundSourceLocation, ParsedTokenSyntax LeftParen, Optional<ParsedPoundSourceLocationArgsSyntax> Args, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundSourceLocation, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundSourceLocation.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Args.hasValue() ? Args->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundSourceLocationSyntax(std::move(raw));
}

ParsedPoundSourceLocationSyntax
ParsedSyntaxRecorder::deferPoundSourceLocation(ParsedTokenSyntax PoundSourceLocation, ParsedTokenSyntax LeftParen, Optional<ParsedPoundSourceLocationArgsSyntax> Args, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundSourceLocation, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundSourceLocation.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Args.hasValue() ? Args->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundSourceLocationSyntax(std::move(raw));
}

ParsedPoundSourceLocationSyntax
ParsedSyntaxRecorder::makePoundSourceLocation(ParsedTokenSyntax PoundSourceLocation, ParsedTokenSyntax LeftParen, Optional<ParsedPoundSourceLocationArgsSyntax> Args, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundSourceLocation(std::move(PoundSourceLocation), std::move(LeftParen), std::move(Args), std::move(RightParen), SPCtx);
  return recordPoundSourceLocation(std::move(PoundSourceLocation), std::move(LeftParen), std::move(Args), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundSourceLocationArgsSyntax
ParsedSyntaxRecorder::recordPoundSourceLocationArgs(ParsedTokenSyntax FileArgLabel, ParsedTokenSyntax FileArgColon, ParsedTokenSyntax FileName, ParsedTokenSyntax Comma, ParsedTokenSyntax LineArgLabel, ParsedTokenSyntax LineArgColon, ParsedTokenSyntax LineNumber,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundSourceLocationArgs, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FileArgLabel.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FileArgColon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FileName.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Comma.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LineArgLabel.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LineArgColon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LineNumber.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundSourceLocationArgsSyntax(std::move(raw));
}

ParsedPoundSourceLocationArgsSyntax
ParsedSyntaxRecorder::deferPoundSourceLocationArgs(ParsedTokenSyntax FileArgLabel, ParsedTokenSyntax FileArgColon, ParsedTokenSyntax FileName, ParsedTokenSyntax Comma, ParsedTokenSyntax LineArgLabel, ParsedTokenSyntax LineArgColon, ParsedTokenSyntax LineNumber, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundSourceLocationArgs, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FileArgLabel.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FileArgColon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FileName.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Comma.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LineArgLabel.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LineArgColon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LineNumber.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundSourceLocationArgsSyntax(std::move(raw));
}

ParsedPoundSourceLocationArgsSyntax
ParsedSyntaxRecorder::makePoundSourceLocationArgs(ParsedTokenSyntax FileArgLabel, ParsedTokenSyntax FileArgColon, ParsedTokenSyntax FileName, ParsedTokenSyntax Comma, ParsedTokenSyntax LineArgLabel, ParsedTokenSyntax LineArgColon, ParsedTokenSyntax LineNumber,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundSourceLocationArgs(std::move(FileArgLabel), std::move(FileArgColon), std::move(FileName), std::move(Comma), std::move(LineArgLabel), std::move(LineArgColon), std::move(LineNumber), SPCtx);
  return recordPoundSourceLocationArgs(std::move(FileArgLabel), std::move(FileArgColon), std::move(FileName), std::move(Comma), std::move(LineArgLabel), std::move(LineArgColon), std::move(LineNumber), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDeclModifierSyntax
ParsedSyntaxRecorder::recordDeclModifier(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> DetailLeftParen, Optional<ParsedTokenSyntax> Detail, Optional<ParsedTokenSyntax> DetailRightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DeclModifier, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DetailLeftParen.hasValue() ? DetailLeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Detail.hasValue() ? Detail->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DetailRightParen.hasValue() ? DetailRightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDeclModifierSyntax(std::move(raw));
}

ParsedDeclModifierSyntax
ParsedSyntaxRecorder::deferDeclModifier(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> DetailLeftParen, Optional<ParsedTokenSyntax> Detail, Optional<ParsedTokenSyntax> DetailRightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DeclModifier, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DetailLeftParen.hasValue() ? DetailLeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Detail.hasValue() ? Detail->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DetailRightParen.hasValue() ? DetailRightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDeclModifierSyntax(std::move(raw));
}

ParsedDeclModifierSyntax
ParsedSyntaxRecorder::makeDeclModifier(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> DetailLeftParen, Optional<ParsedTokenSyntax> Detail, Optional<ParsedTokenSyntax> DetailRightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDeclModifier(std::move(Name), std::move(DetailLeftParen), std::move(Detail), std::move(DetailRightParen), SPCtx);
  return recordDeclModifier(std::move(Name), std::move(DetailLeftParen), std::move(Detail), std::move(DetailRightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedInheritedTypeSyntax
ParsedSyntaxRecorder::recordInheritedType(ParsedTypeSyntax TypeName, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::InheritedType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeName.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedInheritedTypeSyntax(std::move(raw));
}

ParsedInheritedTypeSyntax
ParsedSyntaxRecorder::deferInheritedType(ParsedTypeSyntax TypeName, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::InheritedType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeName.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedInheritedTypeSyntax(std::move(raw));
}

ParsedInheritedTypeSyntax
ParsedSyntaxRecorder::makeInheritedType(ParsedTypeSyntax TypeName, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferInheritedType(std::move(TypeName), std::move(TrailingComma), SPCtx);
  return recordInheritedType(std::move(TypeName), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedInheritedTypeListSyntax
ParsedSyntaxRecorder::recordInheritedTypeList(
    ArrayRef<ParsedInheritedTypeSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::InheritedTypeList, layout);
  return ParsedInheritedTypeListSyntax(std::move(raw));
}

ParsedInheritedTypeListSyntax
ParsedSyntaxRecorder::deferInheritedTypeList(
    ArrayRef<ParsedInheritedTypeSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::InheritedTypeList,
                             layout, SPCtx);
  return ParsedInheritedTypeListSyntax(std::move(raw));
}

ParsedInheritedTypeListSyntax
ParsedSyntaxRecorder::makeInheritedTypeList(
    ArrayRef<ParsedInheritedTypeSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferInheritedTypeList(elements, SPCtx);
  return recordInheritedTypeList(elements, SPCtx.getRecorder());
}

ParsedInheritedTypeListSyntax
ParsedSyntaxRecorder::makeBlankInheritedTypeList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::InheritedTypeList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::InheritedTypeList, loc);
  }
  return ParsedInheritedTypeListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTypeInheritanceClauseSyntax
ParsedSyntaxRecorder::recordTypeInheritanceClause(ParsedTokenSyntax Colon, ParsedInheritedTypeListSyntax InheritedTypeCollection,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TypeInheritanceClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritedTypeCollection.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTypeInheritanceClauseSyntax(std::move(raw));
}

ParsedTypeInheritanceClauseSyntax
ParsedSyntaxRecorder::deferTypeInheritanceClause(ParsedTokenSyntax Colon, ParsedInheritedTypeListSyntax InheritedTypeCollection, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TypeInheritanceClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritedTypeCollection.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTypeInheritanceClauseSyntax(std::move(raw));
}

ParsedTypeInheritanceClauseSyntax
ParsedSyntaxRecorder::makeTypeInheritanceClause(ParsedTokenSyntax Colon, ParsedInheritedTypeListSyntax InheritedTypeCollection,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTypeInheritanceClause(std::move(Colon), std::move(InheritedTypeCollection), SPCtx);
  return recordTypeInheritanceClause(std::move(Colon), std::move(InheritedTypeCollection), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedClassDeclSyntax
ParsedSyntaxRecorder::recordClassDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ClassKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ClassDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ClassKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedClassDeclSyntax(std::move(raw));
}

ParsedClassDeclSyntax
ParsedSyntaxRecorder::deferClassDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ClassKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClassDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ClassKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedClassDeclSyntax(std::move(raw));
}

ParsedClassDeclSyntax
ParsedSyntaxRecorder::makeClassDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ClassKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferClassDecl(std::move(Attributes), std::move(Modifiers), std::move(ClassKeyword), std::move(Identifier), std::move(GenericParameterClause), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx);
  return recordClassDecl(std::move(Attributes), std::move(Modifiers), std::move(ClassKeyword), std::move(Identifier), std::move(GenericParameterClause), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedStructDeclSyntax
ParsedSyntaxRecorder::recordStructDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax StructKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::StructDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    StructKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedStructDeclSyntax(std::move(raw));
}

ParsedStructDeclSyntax
ParsedSyntaxRecorder::deferStructDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax StructKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::StructDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    StructKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedStructDeclSyntax(std::move(raw));
}

ParsedStructDeclSyntax
ParsedSyntaxRecorder::makeStructDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax StructKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferStructDecl(std::move(Attributes), std::move(Modifiers), std::move(StructKeyword), std::move(Identifier), std::move(GenericParameterClause), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx);
  return recordStructDecl(std::move(Attributes), std::move(Modifiers), std::move(StructKeyword), std::move(Identifier), std::move(GenericParameterClause), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedProtocolDeclSyntax
ParsedSyntaxRecorder::recordProtocolDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ProtocolKeyword, ParsedTokenSyntax Identifier, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ProtocolDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ProtocolKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedProtocolDeclSyntax(std::move(raw));
}

ParsedProtocolDeclSyntax
ParsedSyntaxRecorder::deferProtocolDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ProtocolKeyword, ParsedTokenSyntax Identifier, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ProtocolDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ProtocolKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedProtocolDeclSyntax(std::move(raw));
}

ParsedProtocolDeclSyntax
ParsedSyntaxRecorder::makeProtocolDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ProtocolKeyword, ParsedTokenSyntax Identifier, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferProtocolDecl(std::move(Attributes), std::move(Modifiers), std::move(ProtocolKeyword), std::move(Identifier), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx);
  return recordProtocolDecl(std::move(Attributes), std::move(Modifiers), std::move(ProtocolKeyword), std::move(Identifier), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedExtensionDeclSyntax
ParsedSyntaxRecorder::recordExtensionDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ExtensionKeyword, ParsedTypeSyntax ExtendedType, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ExtensionDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ExtensionKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ExtendedType.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedExtensionDeclSyntax(std::move(raw));
}

ParsedExtensionDeclSyntax
ParsedSyntaxRecorder::deferExtensionDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ExtensionKeyword, ParsedTypeSyntax ExtendedType, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ExtensionDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ExtensionKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ExtendedType.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedExtensionDeclSyntax(std::move(raw));
}

ParsedExtensionDeclSyntax
ParsedSyntaxRecorder::makeExtensionDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ExtensionKeyword, ParsedTypeSyntax ExtendedType, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferExtensionDecl(std::move(Attributes), std::move(Modifiers), std::move(ExtensionKeyword), std::move(ExtendedType), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx);
  return recordExtensionDecl(std::move(Attributes), std::move(Modifiers), std::move(ExtensionKeyword), std::move(ExtendedType), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedMemberDeclBlockSyntax
ParsedSyntaxRecorder::recordMemberDeclBlock(ParsedTokenSyntax LeftBrace, ParsedMemberDeclListSyntax Members, ParsedTokenSyntax RightBrace,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::MemberDeclBlock, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedMemberDeclBlockSyntax(std::move(raw));
}

ParsedMemberDeclBlockSyntax
ParsedSyntaxRecorder::deferMemberDeclBlock(ParsedTokenSyntax LeftBrace, ParsedMemberDeclListSyntax Members, ParsedTokenSyntax RightBrace, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::MemberDeclBlock, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedMemberDeclBlockSyntax(std::move(raw));
}

ParsedMemberDeclBlockSyntax
ParsedSyntaxRecorder::makeMemberDeclBlock(ParsedTokenSyntax LeftBrace, ParsedMemberDeclListSyntax Members, ParsedTokenSyntax RightBrace,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferMemberDeclBlock(std::move(LeftBrace), std::move(Members), std::move(RightBrace), SPCtx);
  return recordMemberDeclBlock(std::move(LeftBrace), std::move(Members), std::move(RightBrace), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedMemberDeclListSyntax
ParsedSyntaxRecorder::recordMemberDeclList(
    ArrayRef<ParsedMemberDeclListItemSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::MemberDeclList, layout);
  return ParsedMemberDeclListSyntax(std::move(raw));
}

ParsedMemberDeclListSyntax
ParsedSyntaxRecorder::deferMemberDeclList(
    ArrayRef<ParsedMemberDeclListItemSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::MemberDeclList,
                             layout, SPCtx);
  return ParsedMemberDeclListSyntax(std::move(raw));
}

ParsedMemberDeclListSyntax
ParsedSyntaxRecorder::makeMemberDeclList(
    ArrayRef<ParsedMemberDeclListItemSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferMemberDeclList(elements, SPCtx);
  return recordMemberDeclList(elements, SPCtx.getRecorder());
}

ParsedMemberDeclListSyntax
ParsedSyntaxRecorder::makeBlankMemberDeclList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::MemberDeclList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::MemberDeclList, loc);
  }
  return ParsedMemberDeclListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedMemberDeclListItemSyntax
ParsedSyntaxRecorder::recordMemberDeclListItem(ParsedDeclSyntax Decl, Optional<ParsedTokenSyntax> Semicolon,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::MemberDeclListItem, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Decl.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Semicolon.hasValue() ? Semicolon->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedMemberDeclListItemSyntax(std::move(raw));
}

ParsedMemberDeclListItemSyntax
ParsedSyntaxRecorder::deferMemberDeclListItem(ParsedDeclSyntax Decl, Optional<ParsedTokenSyntax> Semicolon, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::MemberDeclListItem, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Decl.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Semicolon.hasValue() ? Semicolon->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedMemberDeclListItemSyntax(std::move(raw));
}

ParsedMemberDeclListItemSyntax
ParsedSyntaxRecorder::makeMemberDeclListItem(ParsedDeclSyntax Decl, Optional<ParsedTokenSyntax> Semicolon,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferMemberDeclListItem(std::move(Decl), std::move(Semicolon), SPCtx);
  return recordMemberDeclListItem(std::move(Decl), std::move(Semicolon), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSourceFileSyntax
ParsedSyntaxRecorder::recordSourceFile(ParsedCodeBlockItemListSyntax Statements, ParsedTokenSyntax EOFToken,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SourceFile, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Statements.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    EOFToken.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSourceFileSyntax(std::move(raw));
}

ParsedSourceFileSyntax
ParsedSyntaxRecorder::deferSourceFile(ParsedCodeBlockItemListSyntax Statements, ParsedTokenSyntax EOFToken, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SourceFile, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Statements.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    EOFToken.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSourceFileSyntax(std::move(raw));
}

ParsedSourceFileSyntax
ParsedSyntaxRecorder::makeSourceFile(ParsedCodeBlockItemListSyntax Statements, ParsedTokenSyntax EOFToken,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSourceFile(std::move(Statements), std::move(EOFToken), SPCtx);
  return recordSourceFile(std::move(Statements), std::move(EOFToken), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedInitializerClauseSyntax
ParsedSyntaxRecorder::recordInitializerClause(ParsedTokenSyntax Equal, ParsedExprSyntax Value,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::InitializerClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Equal.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedInitializerClauseSyntax(std::move(raw));
}

ParsedInitializerClauseSyntax
ParsedSyntaxRecorder::deferInitializerClause(ParsedTokenSyntax Equal, ParsedExprSyntax Value, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::InitializerClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Equal.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedInitializerClauseSyntax(std::move(raw));
}

ParsedInitializerClauseSyntax
ParsedSyntaxRecorder::makeInitializerClause(ParsedTokenSyntax Equal, ParsedExprSyntax Value,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferInitializerClause(std::move(Equal), std::move(Value), SPCtx);
  return recordInitializerClause(std::move(Equal), std::move(Value), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFunctionParameterSyntax
ParsedSyntaxRecorder::recordFunctionParameter(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedTokenSyntax> FirstName, Optional<ParsedTokenSyntax> SecondName, Optional<ParsedTokenSyntax> Colon, Optional<ParsedTypeSyntax> Type, Optional<ParsedTokenSyntax> Ellipsis, Optional<ParsedInitializerClauseSyntax> DefaultArgument, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::FunctionParameter, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FirstName.hasValue() ? FirstName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SecondName.hasValue() ? SecondName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.hasValue() ? Type->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Ellipsis.hasValue() ? Ellipsis->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DefaultArgument.hasValue() ? DefaultArgument->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedFunctionParameterSyntax(std::move(raw));
}

ParsedFunctionParameterSyntax
ParsedSyntaxRecorder::deferFunctionParameter(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedTokenSyntax> FirstName, Optional<ParsedTokenSyntax> SecondName, Optional<ParsedTokenSyntax> Colon, Optional<ParsedTypeSyntax> Type, Optional<ParsedTokenSyntax> Ellipsis, Optional<ParsedInitializerClauseSyntax> DefaultArgument, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionParameter, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FirstName.hasValue() ? FirstName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SecondName.hasValue() ? SecondName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.hasValue() ? Type->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Ellipsis.hasValue() ? Ellipsis->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DefaultArgument.hasValue() ? DefaultArgument->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedFunctionParameterSyntax(std::move(raw));
}

ParsedFunctionParameterSyntax
ParsedSyntaxRecorder::makeFunctionParameter(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedTokenSyntax> FirstName, Optional<ParsedTokenSyntax> SecondName, Optional<ParsedTokenSyntax> Colon, Optional<ParsedTypeSyntax> Type, Optional<ParsedTokenSyntax> Ellipsis, Optional<ParsedInitializerClauseSyntax> DefaultArgument, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFunctionParameter(std::move(Attributes), std::move(FirstName), std::move(SecondName), std::move(Colon), std::move(Type), std::move(Ellipsis), std::move(DefaultArgument), std::move(TrailingComma), SPCtx);
  return recordFunctionParameter(std::move(Attributes), std::move(FirstName), std::move(SecondName), std::move(Colon), std::move(Type), std::move(Ellipsis), std::move(DefaultArgument), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedModifierListSyntax
ParsedSyntaxRecorder::recordModifierList(
    ArrayRef<ParsedDeclModifierSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::ModifierList, layout);
  return ParsedModifierListSyntax(std::move(raw));
}

ParsedModifierListSyntax
ParsedSyntaxRecorder::deferModifierList(
    ArrayRef<ParsedDeclModifierSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ModifierList,
                             layout, SPCtx);
  return ParsedModifierListSyntax(std::move(raw));
}

ParsedModifierListSyntax
ParsedSyntaxRecorder::makeModifierList(
    ArrayRef<ParsedDeclModifierSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferModifierList(elements, SPCtx);
  return recordModifierList(elements, SPCtx.getRecorder());
}

ParsedModifierListSyntax
ParsedSyntaxRecorder::makeBlankModifierList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ModifierList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::ModifierList, loc);
  }
  return ParsedModifierListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFunctionDeclSyntax
ParsedSyntaxRecorder::recordFunctionDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax FuncKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, ParsedFunctionSignatureSyntax Signature, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, Optional<ParsedCodeBlockSyntax> Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::FunctionDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FuncKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Signature.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.hasValue() ? Body->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedFunctionDeclSyntax(std::move(raw));
}

ParsedFunctionDeclSyntax
ParsedSyntaxRecorder::deferFunctionDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax FuncKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, ParsedFunctionSignatureSyntax Signature, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, Optional<ParsedCodeBlockSyntax> Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FuncKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Signature.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.hasValue() ? Body->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedFunctionDeclSyntax(std::move(raw));
}

ParsedFunctionDeclSyntax
ParsedSyntaxRecorder::makeFunctionDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax FuncKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, ParsedFunctionSignatureSyntax Signature, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, Optional<ParsedCodeBlockSyntax> Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFunctionDecl(std::move(Attributes), std::move(Modifiers), std::move(FuncKeyword), std::move(Identifier), std::move(GenericParameterClause), std::move(Signature), std::move(GenericWhereClause), std::move(Body), SPCtx);
  return recordFunctionDecl(std::move(Attributes), std::move(Modifiers), std::move(FuncKeyword), std::move(Identifier), std::move(GenericParameterClause), std::move(Signature), std::move(GenericWhereClause), std::move(Body), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedInitializerDeclSyntax
ParsedSyntaxRecorder::recordInitializerDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax InitKeyword, Optional<ParsedTokenSyntax> OptionalMark, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, ParsedParameterClauseSyntax Parameters, Optional<ParsedTokenSyntax> ThrowsOrRethrowsKeyword, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, Optional<ParsedCodeBlockSyntax> Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::InitializerDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InitKeyword.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OptionalMark.hasValue() ? OptionalMark->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Parameters.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsOrRethrowsKeyword.hasValue() ? ThrowsOrRethrowsKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.hasValue() ? Body->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedInitializerDeclSyntax(std::move(raw));
}

ParsedInitializerDeclSyntax
ParsedSyntaxRecorder::deferInitializerDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax InitKeyword, Optional<ParsedTokenSyntax> OptionalMark, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, ParsedParameterClauseSyntax Parameters, Optional<ParsedTokenSyntax> ThrowsOrRethrowsKeyword, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, Optional<ParsedCodeBlockSyntax> Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::InitializerDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InitKeyword.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OptionalMark.hasValue() ? OptionalMark->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Parameters.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsOrRethrowsKeyword.hasValue() ? ThrowsOrRethrowsKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.hasValue() ? Body->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedInitializerDeclSyntax(std::move(raw));
}

ParsedInitializerDeclSyntax
ParsedSyntaxRecorder::makeInitializerDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax InitKeyword, Optional<ParsedTokenSyntax> OptionalMark, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, ParsedParameterClauseSyntax Parameters, Optional<ParsedTokenSyntax> ThrowsOrRethrowsKeyword, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, Optional<ParsedCodeBlockSyntax> Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferInitializerDecl(std::move(Attributes), std::move(Modifiers), std::move(InitKeyword), std::move(OptionalMark), std::move(GenericParameterClause), std::move(Parameters), std::move(ThrowsOrRethrowsKeyword), std::move(GenericWhereClause), std::move(Body), SPCtx);
  return recordInitializerDecl(std::move(Attributes), std::move(Modifiers), std::move(InitKeyword), std::move(OptionalMark), std::move(GenericParameterClause), std::move(Parameters), std::move(ThrowsOrRethrowsKeyword), std::move(GenericWhereClause), std::move(Body), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDeinitializerDeclSyntax
ParsedSyntaxRecorder::recordDeinitializerDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax DeinitKeyword, ParsedCodeBlockSyntax Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DeinitializerDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeinitKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDeinitializerDeclSyntax(std::move(raw));
}

ParsedDeinitializerDeclSyntax
ParsedSyntaxRecorder::deferDeinitializerDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax DeinitKeyword, ParsedCodeBlockSyntax Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DeinitializerDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeinitKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDeinitializerDeclSyntax(std::move(raw));
}

ParsedDeinitializerDeclSyntax
ParsedSyntaxRecorder::makeDeinitializerDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax DeinitKeyword, ParsedCodeBlockSyntax Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDeinitializerDecl(std::move(Attributes), std::move(Modifiers), std::move(DeinitKeyword), std::move(Body), SPCtx);
  return recordDeinitializerDecl(std::move(Attributes), std::move(Modifiers), std::move(DeinitKeyword), std::move(Body), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSubscriptDeclSyntax
ParsedSyntaxRecorder::recordSubscriptDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax SubscriptKeyword, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, ParsedParameterClauseSyntax Indices, ParsedReturnClauseSyntax Result, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, Optional<ParsedSyntax> Accessor,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SubscriptDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SubscriptKeyword.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Indices.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Result.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Accessor.hasValue() ? Accessor->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSubscriptDeclSyntax(std::move(raw));
}

ParsedSubscriptDeclSyntax
ParsedSyntaxRecorder::deferSubscriptDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax SubscriptKeyword, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, ParsedParameterClauseSyntax Indices, ParsedReturnClauseSyntax Result, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, Optional<ParsedSyntax> Accessor, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SubscriptDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SubscriptKeyword.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterClause.hasValue() ? GenericParameterClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Indices.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Result.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Accessor.hasValue() ? Accessor->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSubscriptDeclSyntax(std::move(raw));
}

ParsedSubscriptDeclSyntax
ParsedSyntaxRecorder::makeSubscriptDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax SubscriptKeyword, Optional<ParsedGenericParameterClauseSyntax> GenericParameterClause, ParsedParameterClauseSyntax Indices, ParsedReturnClauseSyntax Result, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, Optional<ParsedSyntax> Accessor,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSubscriptDecl(std::move(Attributes), std::move(Modifiers), std::move(SubscriptKeyword), std::move(GenericParameterClause), std::move(Indices), std::move(Result), std::move(GenericWhereClause), std::move(Accessor), SPCtx);
  return recordSubscriptDecl(std::move(Attributes), std::move(Modifiers), std::move(SubscriptKeyword), std::move(GenericParameterClause), std::move(Indices), std::move(Result), std::move(GenericWhereClause), std::move(Accessor), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAccessLevelModifierSyntax
ParsedSyntaxRecorder::recordAccessLevelModifier(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> LeftParen, Optional<ParsedTokenSyntax> Modifier, Optional<ParsedTokenSyntax> RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AccessLevelModifier, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.hasValue() ? LeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifier.hasValue() ? Modifier->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.hasValue() ? RightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAccessLevelModifierSyntax(std::move(raw));
}

ParsedAccessLevelModifierSyntax
ParsedSyntaxRecorder::deferAccessLevelModifier(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> LeftParen, Optional<ParsedTokenSyntax> Modifier, Optional<ParsedTokenSyntax> RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AccessLevelModifier, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.hasValue() ? LeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifier.hasValue() ? Modifier->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.hasValue() ? RightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAccessLevelModifierSyntax(std::move(raw));
}

ParsedAccessLevelModifierSyntax
ParsedSyntaxRecorder::makeAccessLevelModifier(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> LeftParen, Optional<ParsedTokenSyntax> Modifier, Optional<ParsedTokenSyntax> RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAccessLevelModifier(std::move(Name), std::move(LeftParen), std::move(Modifier), std::move(RightParen), SPCtx);
  return recordAccessLevelModifier(std::move(Name), std::move(LeftParen), std::move(Modifier), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAccessPathComponentSyntax
ParsedSyntaxRecorder::recordAccessPathComponent(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> TrailingDot,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AccessPathComponent, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingDot.hasValue() ? TrailingDot->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAccessPathComponentSyntax(std::move(raw));
}

ParsedAccessPathComponentSyntax
ParsedSyntaxRecorder::deferAccessPathComponent(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> TrailingDot, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AccessPathComponent, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingDot.hasValue() ? TrailingDot->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAccessPathComponentSyntax(std::move(raw));
}

ParsedAccessPathComponentSyntax
ParsedSyntaxRecorder::makeAccessPathComponent(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> TrailingDot,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAccessPathComponent(std::move(Name), std::move(TrailingDot), SPCtx);
  return recordAccessPathComponent(std::move(Name), std::move(TrailingDot), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAccessPathSyntax
ParsedSyntaxRecorder::recordAccessPath(
    ArrayRef<ParsedAccessPathComponentSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::AccessPath, layout);
  return ParsedAccessPathSyntax(std::move(raw));
}

ParsedAccessPathSyntax
ParsedSyntaxRecorder::deferAccessPath(
    ArrayRef<ParsedAccessPathComponentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AccessPath,
                             layout, SPCtx);
  return ParsedAccessPathSyntax(std::move(raw));
}

ParsedAccessPathSyntax
ParsedSyntaxRecorder::makeAccessPath(
    ArrayRef<ParsedAccessPathComponentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAccessPath(elements, SPCtx);
  return recordAccessPath(elements, SPCtx.getRecorder());
}

ParsedAccessPathSyntax
ParsedSyntaxRecorder::makeBlankAccessPath(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AccessPath, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::AccessPath, loc);
  }
  return ParsedAccessPathSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedImportDeclSyntax
ParsedSyntaxRecorder::recordImportDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ImportTok, Optional<ParsedTokenSyntax> ImportKind, ParsedAccessPathSyntax Path,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ImportDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ImportTok.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ImportKind.hasValue() ? ImportKind->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Path.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedImportDeclSyntax(std::move(raw));
}

ParsedImportDeclSyntax
ParsedSyntaxRecorder::deferImportDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ImportTok, Optional<ParsedTokenSyntax> ImportKind, ParsedAccessPathSyntax Path, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ImportDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ImportTok.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ImportKind.hasValue() ? ImportKind->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Path.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedImportDeclSyntax(std::move(raw));
}

ParsedImportDeclSyntax
ParsedSyntaxRecorder::makeImportDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax ImportTok, Optional<ParsedTokenSyntax> ImportKind, ParsedAccessPathSyntax Path,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferImportDecl(std::move(Attributes), std::move(Modifiers), std::move(ImportTok), std::move(ImportKind), std::move(Path), SPCtx);
  return recordImportDecl(std::move(Attributes), std::move(Modifiers), std::move(ImportTok), std::move(ImportKind), std::move(Path), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAccessorParameterSyntax
ParsedSyntaxRecorder::recordAccessorParameter(ParsedTokenSyntax LeftParen, ParsedTokenSyntax Name, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AccessorParameter, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAccessorParameterSyntax(std::move(raw));
}

ParsedAccessorParameterSyntax
ParsedSyntaxRecorder::deferAccessorParameter(ParsedTokenSyntax LeftParen, ParsedTokenSyntax Name, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AccessorParameter, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAccessorParameterSyntax(std::move(raw));
}

ParsedAccessorParameterSyntax
ParsedSyntaxRecorder::makeAccessorParameter(ParsedTokenSyntax LeftParen, ParsedTokenSyntax Name, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAccessorParameter(std::move(LeftParen), std::move(Name), std::move(RightParen), SPCtx);
  return recordAccessorParameter(std::move(LeftParen), std::move(Name), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAccessorDeclSyntax
ParsedSyntaxRecorder::recordAccessorDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedDeclModifierSyntax> Modifier, ParsedTokenSyntax AccessorKind, Optional<ParsedAccessorParameterSyntax> Parameter, Optional<ParsedCodeBlockSyntax> Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AccessorDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifier.hasValue() ? Modifier->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AccessorKind.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Parameter.hasValue() ? Parameter->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.hasValue() ? Body->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAccessorDeclSyntax(std::move(raw));
}

ParsedAccessorDeclSyntax
ParsedSyntaxRecorder::deferAccessorDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedDeclModifierSyntax> Modifier, ParsedTokenSyntax AccessorKind, Optional<ParsedAccessorParameterSyntax> Parameter, Optional<ParsedCodeBlockSyntax> Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AccessorDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifier.hasValue() ? Modifier->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AccessorKind.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Parameter.hasValue() ? Parameter->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.hasValue() ? Body->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAccessorDeclSyntax(std::move(raw));
}

ParsedAccessorDeclSyntax
ParsedSyntaxRecorder::makeAccessorDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedDeclModifierSyntax> Modifier, ParsedTokenSyntax AccessorKind, Optional<ParsedAccessorParameterSyntax> Parameter, Optional<ParsedCodeBlockSyntax> Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAccessorDecl(std::move(Attributes), std::move(Modifier), std::move(AccessorKind), std::move(Parameter), std::move(Body), SPCtx);
  return recordAccessorDecl(std::move(Attributes), std::move(Modifier), std::move(AccessorKind), std::move(Parameter), std::move(Body), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAccessorListSyntax
ParsedSyntaxRecorder::recordAccessorList(
    ArrayRef<ParsedAccessorDeclSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::AccessorList, layout);
  return ParsedAccessorListSyntax(std::move(raw));
}

ParsedAccessorListSyntax
ParsedSyntaxRecorder::deferAccessorList(
    ArrayRef<ParsedAccessorDeclSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AccessorList,
                             layout, SPCtx);
  return ParsedAccessorListSyntax(std::move(raw));
}

ParsedAccessorListSyntax
ParsedSyntaxRecorder::makeAccessorList(
    ArrayRef<ParsedAccessorDeclSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAccessorList(elements, SPCtx);
  return recordAccessorList(elements, SPCtx.getRecorder());
}

ParsedAccessorListSyntax
ParsedSyntaxRecorder::makeBlankAccessorList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AccessorList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::AccessorList, loc);
  }
  return ParsedAccessorListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAccessorBlockSyntax
ParsedSyntaxRecorder::recordAccessorBlock(ParsedTokenSyntax LeftBrace, ParsedAccessorListSyntax Accessors, ParsedTokenSyntax RightBrace,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AccessorBlock, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Accessors.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAccessorBlockSyntax(std::move(raw));
}

ParsedAccessorBlockSyntax
ParsedSyntaxRecorder::deferAccessorBlock(ParsedTokenSyntax LeftBrace, ParsedAccessorListSyntax Accessors, ParsedTokenSyntax RightBrace, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AccessorBlock, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Accessors.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAccessorBlockSyntax(std::move(raw));
}

ParsedAccessorBlockSyntax
ParsedSyntaxRecorder::makeAccessorBlock(ParsedTokenSyntax LeftBrace, ParsedAccessorListSyntax Accessors, ParsedTokenSyntax RightBrace,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAccessorBlock(std::move(LeftBrace), std::move(Accessors), std::move(RightBrace), SPCtx);
  return recordAccessorBlock(std::move(LeftBrace), std::move(Accessors), std::move(RightBrace), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPatternBindingSyntax
ParsedSyntaxRecorder::recordPatternBinding(ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, Optional<ParsedInitializerClauseSyntax> Initializer, Optional<ParsedSyntax> Accessor, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PatternBinding, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.hasValue() ? Initializer->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Accessor.hasValue() ? Accessor->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPatternBindingSyntax(std::move(raw));
}

ParsedPatternBindingSyntax
ParsedSyntaxRecorder::deferPatternBinding(ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, Optional<ParsedInitializerClauseSyntax> Initializer, Optional<ParsedSyntax> Accessor, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PatternBinding, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.hasValue() ? Initializer->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Accessor.hasValue() ? Accessor->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPatternBindingSyntax(std::move(raw));
}

ParsedPatternBindingSyntax
ParsedSyntaxRecorder::makePatternBinding(ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, Optional<ParsedInitializerClauseSyntax> Initializer, Optional<ParsedSyntax> Accessor, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPatternBinding(std::move(Pattern), std::move(TypeAnnotation), std::move(Initializer), std::move(Accessor), std::move(TrailingComma), SPCtx);
  return recordPatternBinding(std::move(Pattern), std::move(TypeAnnotation), std::move(Initializer), std::move(Accessor), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPatternBindingListSyntax
ParsedSyntaxRecorder::recordPatternBindingList(
    ArrayRef<ParsedPatternBindingSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::PatternBindingList, layout);
  return ParsedPatternBindingListSyntax(std::move(raw));
}

ParsedPatternBindingListSyntax
ParsedSyntaxRecorder::deferPatternBindingList(
    ArrayRef<ParsedPatternBindingSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PatternBindingList,
                             layout, SPCtx);
  return ParsedPatternBindingListSyntax(std::move(raw));
}

ParsedPatternBindingListSyntax
ParsedSyntaxRecorder::makePatternBindingList(
    ArrayRef<ParsedPatternBindingSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPatternBindingList(elements, SPCtx);
  return recordPatternBindingList(elements, SPCtx.getRecorder());
}

ParsedPatternBindingListSyntax
ParsedSyntaxRecorder::makeBlankPatternBindingList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PatternBindingList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::PatternBindingList, loc);
  }
  return ParsedPatternBindingListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedVariableDeclSyntax
ParsedSyntaxRecorder::recordVariableDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax LetOrVarKeyword, ParsedPatternBindingListSyntax Bindings,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::VariableDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LetOrVarKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Bindings.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedVariableDeclSyntax(std::move(raw));
}

ParsedVariableDeclSyntax
ParsedSyntaxRecorder::deferVariableDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax LetOrVarKeyword, ParsedPatternBindingListSyntax Bindings, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::VariableDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LetOrVarKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Bindings.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedVariableDeclSyntax(std::move(raw));
}

ParsedVariableDeclSyntax
ParsedSyntaxRecorder::makeVariableDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax LetOrVarKeyword, ParsedPatternBindingListSyntax Bindings,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferVariableDecl(std::move(Attributes), std::move(Modifiers), std::move(LetOrVarKeyword), std::move(Bindings), SPCtx);
  return recordVariableDecl(std::move(Attributes), std::move(Modifiers), std::move(LetOrVarKeyword), std::move(Bindings), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedEnumCaseElementSyntax
ParsedSyntaxRecorder::recordEnumCaseElement(ParsedTokenSyntax Identifier, Optional<ParsedParameterClauseSyntax> AssociatedValue, Optional<ParsedInitializerClauseSyntax> RawValue, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::EnumCaseElement, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssociatedValue.hasValue() ? AssociatedValue->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RawValue.hasValue() ? RawValue->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedEnumCaseElementSyntax(std::move(raw));
}

ParsedEnumCaseElementSyntax
ParsedSyntaxRecorder::deferEnumCaseElement(ParsedTokenSyntax Identifier, Optional<ParsedParameterClauseSyntax> AssociatedValue, Optional<ParsedInitializerClauseSyntax> RawValue, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::EnumCaseElement, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssociatedValue.hasValue() ? AssociatedValue->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RawValue.hasValue() ? RawValue->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedEnumCaseElementSyntax(std::move(raw));
}

ParsedEnumCaseElementSyntax
ParsedSyntaxRecorder::makeEnumCaseElement(ParsedTokenSyntax Identifier, Optional<ParsedParameterClauseSyntax> AssociatedValue, Optional<ParsedInitializerClauseSyntax> RawValue, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferEnumCaseElement(std::move(Identifier), std::move(AssociatedValue), std::move(RawValue), std::move(TrailingComma), SPCtx);
  return recordEnumCaseElement(std::move(Identifier), std::move(AssociatedValue), std::move(RawValue), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedEnumCaseElementListSyntax
ParsedSyntaxRecorder::recordEnumCaseElementList(
    ArrayRef<ParsedEnumCaseElementSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::EnumCaseElementList, layout);
  return ParsedEnumCaseElementListSyntax(std::move(raw));
}

ParsedEnumCaseElementListSyntax
ParsedSyntaxRecorder::deferEnumCaseElementList(
    ArrayRef<ParsedEnumCaseElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::EnumCaseElementList,
                             layout, SPCtx);
  return ParsedEnumCaseElementListSyntax(std::move(raw));
}

ParsedEnumCaseElementListSyntax
ParsedSyntaxRecorder::makeEnumCaseElementList(
    ArrayRef<ParsedEnumCaseElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferEnumCaseElementList(elements, SPCtx);
  return recordEnumCaseElementList(elements, SPCtx.getRecorder());
}

ParsedEnumCaseElementListSyntax
ParsedSyntaxRecorder::makeBlankEnumCaseElementList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::EnumCaseElementList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::EnumCaseElementList, loc);
  }
  return ParsedEnumCaseElementListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedEnumCaseDeclSyntax
ParsedSyntaxRecorder::recordEnumCaseDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax CaseKeyword, ParsedEnumCaseElementListSyntax Elements,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::EnumCaseDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedEnumCaseDeclSyntax(std::move(raw));
}

ParsedEnumCaseDeclSyntax
ParsedSyntaxRecorder::deferEnumCaseDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax CaseKeyword, ParsedEnumCaseElementListSyntax Elements, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::EnumCaseDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedEnumCaseDeclSyntax(std::move(raw));
}

ParsedEnumCaseDeclSyntax
ParsedSyntaxRecorder::makeEnumCaseDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax CaseKeyword, ParsedEnumCaseElementListSyntax Elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferEnumCaseDecl(std::move(Attributes), std::move(Modifiers), std::move(CaseKeyword), std::move(Elements), SPCtx);
  return recordEnumCaseDecl(std::move(Attributes), std::move(Modifiers), std::move(CaseKeyword), std::move(Elements), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedEnumDeclSyntax
ParsedSyntaxRecorder::recordEnumDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax EnumKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameters, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::EnumDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    EnumKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameters.hasValue() ? GenericParameters->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedEnumDeclSyntax(std::move(raw));
}

ParsedEnumDeclSyntax
ParsedSyntaxRecorder::deferEnumDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax EnumKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameters, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::EnumDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    EnumKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameters.hasValue() ? GenericParameters->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritanceClause.hasValue() ? InheritanceClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericWhereClause.hasValue() ? GenericWhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Members.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedEnumDeclSyntax(std::move(raw));
}

ParsedEnumDeclSyntax
ParsedSyntaxRecorder::makeEnumDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax EnumKeyword, ParsedTokenSyntax Identifier, Optional<ParsedGenericParameterClauseSyntax> GenericParameters, Optional<ParsedTypeInheritanceClauseSyntax> InheritanceClause, Optional<ParsedGenericWhereClauseSyntax> GenericWhereClause, ParsedMemberDeclBlockSyntax Members,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferEnumDecl(std::move(Attributes), std::move(Modifiers), std::move(EnumKeyword), std::move(Identifier), std::move(GenericParameters), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx);
  return recordEnumDecl(std::move(Attributes), std::move(Modifiers), std::move(EnumKeyword), std::move(Identifier), std::move(GenericParameters), std::move(InheritanceClause), std::move(GenericWhereClause), std::move(Members), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedOperatorDeclSyntax
ParsedSyntaxRecorder::recordOperatorDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax OperatorKeyword, ParsedTokenSyntax Identifier, Optional<ParsedOperatorPrecedenceAndTypesSyntax> OperatorPrecedenceAndTypes,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::OperatorDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorPrecedenceAndTypes.hasValue() ? OperatorPrecedenceAndTypes->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedOperatorDeclSyntax(std::move(raw));
}

ParsedOperatorDeclSyntax
ParsedSyntaxRecorder::deferOperatorDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax OperatorKeyword, ParsedTokenSyntax Identifier, Optional<ParsedOperatorPrecedenceAndTypesSyntax> OperatorPrecedenceAndTypes, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::OperatorDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OperatorPrecedenceAndTypes.hasValue() ? OperatorPrecedenceAndTypes->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedOperatorDeclSyntax(std::move(raw));
}

ParsedOperatorDeclSyntax
ParsedSyntaxRecorder::makeOperatorDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax OperatorKeyword, ParsedTokenSyntax Identifier, Optional<ParsedOperatorPrecedenceAndTypesSyntax> OperatorPrecedenceAndTypes,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferOperatorDecl(std::move(Attributes), std::move(Modifiers), std::move(OperatorKeyword), std::move(Identifier), std::move(OperatorPrecedenceAndTypes), SPCtx);
  return recordOperatorDecl(std::move(Attributes), std::move(Modifiers), std::move(OperatorKeyword), std::move(Identifier), std::move(OperatorPrecedenceAndTypes), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIdentifierListSyntax
ParsedSyntaxRecorder::recordIdentifierList(
    ArrayRef<ParsedTokenSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::IdentifierList, layout);
  return ParsedIdentifierListSyntax(std::move(raw));
}

ParsedIdentifierListSyntax
ParsedSyntaxRecorder::deferIdentifierList(
    ArrayRef<ParsedTokenSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IdentifierList,
                             layout, SPCtx);
  return ParsedIdentifierListSyntax(std::move(raw));
}

ParsedIdentifierListSyntax
ParsedSyntaxRecorder::makeIdentifierList(
    ArrayRef<ParsedTokenSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIdentifierList(elements, SPCtx);
  return recordIdentifierList(elements, SPCtx.getRecorder());
}

ParsedIdentifierListSyntax
ParsedSyntaxRecorder::makeBlankIdentifierList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IdentifierList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::IdentifierList, loc);
  }
  return ParsedIdentifierListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedOperatorPrecedenceAndTypesSyntax
ParsedSyntaxRecorder::recordOperatorPrecedenceAndTypes(ParsedTokenSyntax Colon, ParsedIdentifierListSyntax PrecedenceGroupAndDesignatedTypes,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::OperatorPrecedenceAndTypes, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PrecedenceGroupAndDesignatedTypes.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedOperatorPrecedenceAndTypesSyntax(std::move(raw));
}

ParsedOperatorPrecedenceAndTypesSyntax
ParsedSyntaxRecorder::deferOperatorPrecedenceAndTypes(ParsedTokenSyntax Colon, ParsedIdentifierListSyntax PrecedenceGroupAndDesignatedTypes, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::OperatorPrecedenceAndTypes, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PrecedenceGroupAndDesignatedTypes.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedOperatorPrecedenceAndTypesSyntax(std::move(raw));
}

ParsedOperatorPrecedenceAndTypesSyntax
ParsedSyntaxRecorder::makeOperatorPrecedenceAndTypes(ParsedTokenSyntax Colon, ParsedIdentifierListSyntax PrecedenceGroupAndDesignatedTypes,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferOperatorPrecedenceAndTypes(std::move(Colon), std::move(PrecedenceGroupAndDesignatedTypes), SPCtx);
  return recordOperatorPrecedenceAndTypes(std::move(Colon), std::move(PrecedenceGroupAndDesignatedTypes), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPrecedenceGroupDeclSyntax
ParsedSyntaxRecorder::recordPrecedenceGroupDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax PrecedencegroupKeyword, ParsedTokenSyntax Identifier, ParsedTokenSyntax LeftBrace, ParsedPrecedenceGroupAttributeListSyntax GroupAttributes, ParsedTokenSyntax RightBrace,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PrecedenceGroupDecl, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PrecedencegroupKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GroupAttributes.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPrecedenceGroupDeclSyntax(std::move(raw));
}

ParsedPrecedenceGroupDeclSyntax
ParsedSyntaxRecorder::deferPrecedenceGroupDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax PrecedencegroupKeyword, ParsedTokenSyntax Identifier, ParsedTokenSyntax LeftBrace, ParsedPrecedenceGroupAttributeListSyntax GroupAttributes, ParsedTokenSyntax RightBrace, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrecedenceGroupDecl, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Modifiers.hasValue() ? Modifiers->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PrecedencegroupKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GroupAttributes.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPrecedenceGroupDeclSyntax(std::move(raw));
}

ParsedPrecedenceGroupDeclSyntax
ParsedSyntaxRecorder::makePrecedenceGroupDecl(Optional<ParsedAttributeListSyntax> Attributes, Optional<ParsedModifierListSyntax> Modifiers, ParsedTokenSyntax PrecedencegroupKeyword, ParsedTokenSyntax Identifier, ParsedTokenSyntax LeftBrace, ParsedPrecedenceGroupAttributeListSyntax GroupAttributes, ParsedTokenSyntax RightBrace,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPrecedenceGroupDecl(std::move(Attributes), std::move(Modifiers), std::move(PrecedencegroupKeyword), std::move(Identifier), std::move(LeftBrace), std::move(GroupAttributes), std::move(RightBrace), SPCtx);
  return recordPrecedenceGroupDecl(std::move(Attributes), std::move(Modifiers), std::move(PrecedencegroupKeyword), std::move(Identifier), std::move(LeftBrace), std::move(GroupAttributes), std::move(RightBrace), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPrecedenceGroupAttributeListSyntax
ParsedSyntaxRecorder::recordPrecedenceGroupAttributeList(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::PrecedenceGroupAttributeList, layout);
  return ParsedPrecedenceGroupAttributeListSyntax(std::move(raw));
}

ParsedPrecedenceGroupAttributeListSyntax
ParsedSyntaxRecorder::deferPrecedenceGroupAttributeList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrecedenceGroupAttributeList,
                             layout, SPCtx);
  return ParsedPrecedenceGroupAttributeListSyntax(std::move(raw));
}

ParsedPrecedenceGroupAttributeListSyntax
ParsedSyntaxRecorder::makePrecedenceGroupAttributeList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPrecedenceGroupAttributeList(elements, SPCtx);
  return recordPrecedenceGroupAttributeList(elements, SPCtx.getRecorder());
}

ParsedPrecedenceGroupAttributeListSyntax
ParsedSyntaxRecorder::makeBlankPrecedenceGroupAttributeList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrecedenceGroupAttributeList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::PrecedenceGroupAttributeList, loc);
  }
  return ParsedPrecedenceGroupAttributeListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPrecedenceGroupRelationSyntax
ParsedSyntaxRecorder::recordPrecedenceGroupRelation(ParsedTokenSyntax HigherThanOrLowerThan, ParsedTokenSyntax Colon, ParsedPrecedenceGroupNameListSyntax OtherNames,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PrecedenceGroupRelation, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    HigherThanOrLowerThan.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OtherNames.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPrecedenceGroupRelationSyntax(std::move(raw));
}

ParsedPrecedenceGroupRelationSyntax
ParsedSyntaxRecorder::deferPrecedenceGroupRelation(ParsedTokenSyntax HigherThanOrLowerThan, ParsedTokenSyntax Colon, ParsedPrecedenceGroupNameListSyntax OtherNames, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrecedenceGroupRelation, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    HigherThanOrLowerThan.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    OtherNames.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPrecedenceGroupRelationSyntax(std::move(raw));
}

ParsedPrecedenceGroupRelationSyntax
ParsedSyntaxRecorder::makePrecedenceGroupRelation(ParsedTokenSyntax HigherThanOrLowerThan, ParsedTokenSyntax Colon, ParsedPrecedenceGroupNameListSyntax OtherNames,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPrecedenceGroupRelation(std::move(HigherThanOrLowerThan), std::move(Colon), std::move(OtherNames), SPCtx);
  return recordPrecedenceGroupRelation(std::move(HigherThanOrLowerThan), std::move(Colon), std::move(OtherNames), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPrecedenceGroupNameListSyntax
ParsedSyntaxRecorder::recordPrecedenceGroupNameList(
    ArrayRef<ParsedPrecedenceGroupNameElementSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::PrecedenceGroupNameList, layout);
  return ParsedPrecedenceGroupNameListSyntax(std::move(raw));
}

ParsedPrecedenceGroupNameListSyntax
ParsedSyntaxRecorder::deferPrecedenceGroupNameList(
    ArrayRef<ParsedPrecedenceGroupNameElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrecedenceGroupNameList,
                             layout, SPCtx);
  return ParsedPrecedenceGroupNameListSyntax(std::move(raw));
}

ParsedPrecedenceGroupNameListSyntax
ParsedSyntaxRecorder::makePrecedenceGroupNameList(
    ArrayRef<ParsedPrecedenceGroupNameElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPrecedenceGroupNameList(elements, SPCtx);
  return recordPrecedenceGroupNameList(elements, SPCtx.getRecorder());
}

ParsedPrecedenceGroupNameListSyntax
ParsedSyntaxRecorder::makeBlankPrecedenceGroupNameList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrecedenceGroupNameList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::PrecedenceGroupNameList, loc);
  }
  return ParsedPrecedenceGroupNameListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPrecedenceGroupNameElementSyntax
ParsedSyntaxRecorder::recordPrecedenceGroupNameElement(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PrecedenceGroupNameElement, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPrecedenceGroupNameElementSyntax(std::move(raw));
}

ParsedPrecedenceGroupNameElementSyntax
ParsedSyntaxRecorder::deferPrecedenceGroupNameElement(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrecedenceGroupNameElement, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPrecedenceGroupNameElementSyntax(std::move(raw));
}

ParsedPrecedenceGroupNameElementSyntax
ParsedSyntaxRecorder::makePrecedenceGroupNameElement(ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPrecedenceGroupNameElement(std::move(Name), std::move(TrailingComma), SPCtx);
  return recordPrecedenceGroupNameElement(std::move(Name), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPrecedenceGroupAssignmentSyntax
ParsedSyntaxRecorder::recordPrecedenceGroupAssignment(ParsedTokenSyntax AssignmentKeyword, ParsedTokenSyntax Colon, ParsedTokenSyntax Flag,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PrecedenceGroupAssignment, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssignmentKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Flag.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPrecedenceGroupAssignmentSyntax(std::move(raw));
}

ParsedPrecedenceGroupAssignmentSyntax
ParsedSyntaxRecorder::deferPrecedenceGroupAssignment(ParsedTokenSyntax AssignmentKeyword, ParsedTokenSyntax Colon, ParsedTokenSyntax Flag, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrecedenceGroupAssignment, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssignmentKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Flag.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPrecedenceGroupAssignmentSyntax(std::move(raw));
}

ParsedPrecedenceGroupAssignmentSyntax
ParsedSyntaxRecorder::makePrecedenceGroupAssignment(ParsedTokenSyntax AssignmentKeyword, ParsedTokenSyntax Colon, ParsedTokenSyntax Flag,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPrecedenceGroupAssignment(std::move(AssignmentKeyword), std::move(Colon), std::move(Flag), SPCtx);
  return recordPrecedenceGroupAssignment(std::move(AssignmentKeyword), std::move(Colon), std::move(Flag), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPrecedenceGroupAssociativitySyntax
ParsedSyntaxRecorder::recordPrecedenceGroupAssociativity(ParsedTokenSyntax AssociativityKeyword, ParsedTokenSyntax Colon, ParsedTokenSyntax Value,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PrecedenceGroupAssociativity, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssociativityKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPrecedenceGroupAssociativitySyntax(std::move(raw));
}

ParsedPrecedenceGroupAssociativitySyntax
ParsedSyntaxRecorder::deferPrecedenceGroupAssociativity(ParsedTokenSyntax AssociativityKeyword, ParsedTokenSyntax Colon, ParsedTokenSyntax Value, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PrecedenceGroupAssociativity, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssociativityKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPrecedenceGroupAssociativitySyntax(std::move(raw));
}

ParsedPrecedenceGroupAssociativitySyntax
ParsedSyntaxRecorder::makePrecedenceGroupAssociativity(ParsedTokenSyntax AssociativityKeyword, ParsedTokenSyntax Colon, ParsedTokenSyntax Value,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPrecedenceGroupAssociativity(std::move(AssociativityKeyword), std::move(Colon), std::move(Value), SPCtx);
  return recordPrecedenceGroupAssociativity(std::move(AssociativityKeyword), std::move(Colon), std::move(Value), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTokenListSyntax
ParsedSyntaxRecorder::recordTokenList(
    ArrayRef<ParsedTokenSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::TokenList, layout);
  return ParsedTokenListSyntax(std::move(raw));
}

ParsedTokenListSyntax
ParsedSyntaxRecorder::deferTokenList(
    ArrayRef<ParsedTokenSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TokenList,
                             layout, SPCtx);
  return ParsedTokenListSyntax(std::move(raw));
}

ParsedTokenListSyntax
ParsedSyntaxRecorder::makeTokenList(
    ArrayRef<ParsedTokenSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTokenList(elements, SPCtx);
  return recordTokenList(elements, SPCtx.getRecorder());
}

ParsedTokenListSyntax
ParsedSyntaxRecorder::makeBlankTokenList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TokenList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::TokenList, loc);
  }
  return ParsedTokenListSyntax(std::move(raw));
}
#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedNonEmptyTokenListSyntax
ParsedSyntaxRecorder::recordNonEmptyTokenList(
    ArrayRef<ParsedTokenSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::NonEmptyTokenList, layout);
  return ParsedNonEmptyTokenListSyntax(std::move(raw));
}

ParsedNonEmptyTokenListSyntax
ParsedSyntaxRecorder::deferNonEmptyTokenList(
    ArrayRef<ParsedTokenSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::NonEmptyTokenList,
                             layout, SPCtx);
  return ParsedNonEmptyTokenListSyntax(std::move(raw));
}

ParsedNonEmptyTokenListSyntax
ParsedSyntaxRecorder::makeNonEmptyTokenList(
    ArrayRef<ParsedTokenSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferNonEmptyTokenList(elements, SPCtx);
  return recordNonEmptyTokenList(elements, SPCtx.getRecorder());
}

ParsedNonEmptyTokenListSyntax
ParsedSyntaxRecorder::makeBlankNonEmptyTokenList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::NonEmptyTokenList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::NonEmptyTokenList, loc);
  }
  return ParsedNonEmptyTokenListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCustomAttributeSyntax
ParsedSyntaxRecorder::recordCustomAttribute(ParsedTokenSyntax AtSignToken, ParsedTypeSyntax AttributeName, Optional<ParsedTokenSyntax> LeftParen, Optional<ParsedFunctionCallArgumentListSyntax> ArgumentList, Optional<ParsedTokenSyntax> RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::CustomAttribute, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AtSignToken.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AttributeName.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.hasValue() ? LeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArgumentList.hasValue() ? ArgumentList->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.hasValue() ? RightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedCustomAttributeSyntax(std::move(raw));
}

ParsedCustomAttributeSyntax
ParsedSyntaxRecorder::deferCustomAttribute(ParsedTokenSyntax AtSignToken, ParsedTypeSyntax AttributeName, Optional<ParsedTokenSyntax> LeftParen, Optional<ParsedFunctionCallArgumentListSyntax> ArgumentList, Optional<ParsedTokenSyntax> RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CustomAttribute, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AtSignToken.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AttributeName.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.hasValue() ? LeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArgumentList.hasValue() ? ArgumentList->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.hasValue() ? RightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedCustomAttributeSyntax(std::move(raw));
}

ParsedCustomAttributeSyntax
ParsedSyntaxRecorder::makeCustomAttribute(ParsedTokenSyntax AtSignToken, ParsedTypeSyntax AttributeName, Optional<ParsedTokenSyntax> LeftParen, Optional<ParsedFunctionCallArgumentListSyntax> ArgumentList, Optional<ParsedTokenSyntax> RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCustomAttribute(std::move(AtSignToken), std::move(AttributeName), std::move(LeftParen), std::move(ArgumentList), std::move(RightParen), SPCtx);
  return recordCustomAttribute(std::move(AtSignToken), std::move(AttributeName), std::move(LeftParen), std::move(ArgumentList), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAttributeSyntax
ParsedSyntaxRecorder::recordAttribute(ParsedTokenSyntax AtSignToken, ParsedTokenSyntax AttributeName, Optional<ParsedTokenSyntax> LeftParen, Optional<ParsedSyntax> Argument, Optional<ParsedTokenSyntax> RightParen, Optional<ParsedTokenListSyntax> TokenList,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::Attribute, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AtSignToken.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AttributeName.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.hasValue() ? LeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Argument.hasValue() ? Argument->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.hasValue() ? RightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TokenList.hasValue() ? TokenList->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAttributeSyntax(std::move(raw));
}

ParsedAttributeSyntax
ParsedSyntaxRecorder::deferAttribute(ParsedTokenSyntax AtSignToken, ParsedTokenSyntax AttributeName, Optional<ParsedTokenSyntax> LeftParen, Optional<ParsedSyntax> Argument, Optional<ParsedTokenSyntax> RightParen, Optional<ParsedTokenListSyntax> TokenList, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::Attribute, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AtSignToken.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AttributeName.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.hasValue() ? LeftParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Argument.hasValue() ? Argument->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.hasValue() ? RightParen->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TokenList.hasValue() ? TokenList->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAttributeSyntax(std::move(raw));
}

ParsedAttributeSyntax
ParsedSyntaxRecorder::makeAttribute(ParsedTokenSyntax AtSignToken, ParsedTokenSyntax AttributeName, Optional<ParsedTokenSyntax> LeftParen, Optional<ParsedSyntax> Argument, Optional<ParsedTokenSyntax> RightParen, Optional<ParsedTokenListSyntax> TokenList,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAttribute(std::move(AtSignToken), std::move(AttributeName), std::move(LeftParen), std::move(Argument), std::move(RightParen), std::move(TokenList), SPCtx);
  return recordAttribute(std::move(AtSignToken), std::move(AttributeName), std::move(LeftParen), std::move(Argument), std::move(RightParen), std::move(TokenList), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAttributeListSyntax
ParsedSyntaxRecorder::recordAttributeList(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::AttributeList, layout);
  return ParsedAttributeListSyntax(std::move(raw));
}

ParsedAttributeListSyntax
ParsedSyntaxRecorder::deferAttributeList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AttributeList,
                             layout, SPCtx);
  return ParsedAttributeListSyntax(std::move(raw));
}

ParsedAttributeListSyntax
ParsedSyntaxRecorder::makeAttributeList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAttributeList(elements, SPCtx);
  return recordAttributeList(elements, SPCtx.getRecorder());
}

ParsedAttributeListSyntax
ParsedSyntaxRecorder::makeBlankAttributeList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AttributeList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::AttributeList, loc);
  }
  return ParsedAttributeListSyntax(std::move(raw));
}
#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSpecializeAttributeSpecListSyntax
ParsedSyntaxRecorder::recordSpecializeAttributeSpecList(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::SpecializeAttributeSpecList, layout);
  return ParsedSpecializeAttributeSpecListSyntax(std::move(raw));
}

ParsedSpecializeAttributeSpecListSyntax
ParsedSyntaxRecorder::deferSpecializeAttributeSpecList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SpecializeAttributeSpecList,
                             layout, SPCtx);
  return ParsedSpecializeAttributeSpecListSyntax(std::move(raw));
}

ParsedSpecializeAttributeSpecListSyntax
ParsedSyntaxRecorder::makeSpecializeAttributeSpecList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSpecializeAttributeSpecList(elements, SPCtx);
  return recordSpecializeAttributeSpecList(elements, SPCtx.getRecorder());
}

ParsedSpecializeAttributeSpecListSyntax
ParsedSyntaxRecorder::makeBlankSpecializeAttributeSpecList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SpecializeAttributeSpecList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::SpecializeAttributeSpecList, loc);
  }
  return ParsedSpecializeAttributeSpecListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedLabeledSpecializeEntrySyntax
ParsedSyntaxRecorder::recordLabeledSpecializeEntry(ParsedTokenSyntax Label, ParsedTokenSyntax Colon, ParsedTokenSyntax Value, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::LabeledSpecializeEntry, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedLabeledSpecializeEntrySyntax(std::move(raw));
}

ParsedLabeledSpecializeEntrySyntax
ParsedSyntaxRecorder::deferLabeledSpecializeEntry(ParsedTokenSyntax Label, ParsedTokenSyntax Colon, ParsedTokenSyntax Value, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::LabeledSpecializeEntry, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedLabeledSpecializeEntrySyntax(std::move(raw));
}

ParsedLabeledSpecializeEntrySyntax
ParsedSyntaxRecorder::makeLabeledSpecializeEntry(ParsedTokenSyntax Label, ParsedTokenSyntax Colon, ParsedTokenSyntax Value, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferLabeledSpecializeEntry(std::move(Label), std::move(Colon), std::move(Value), std::move(TrailingComma), SPCtx);
  return recordLabeledSpecializeEntry(std::move(Label), std::move(Colon), std::move(Value), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedNamedAttributeStringArgumentSyntax
ParsedSyntaxRecorder::recordNamedAttributeStringArgument(ParsedTokenSyntax NameTok, ParsedTokenSyntax Colon, ParsedSyntax StringOrDeclname,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::NamedAttributeStringArgument, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    NameTok.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    StringOrDeclname.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedNamedAttributeStringArgumentSyntax(std::move(raw));
}

ParsedNamedAttributeStringArgumentSyntax
ParsedSyntaxRecorder::deferNamedAttributeStringArgument(ParsedTokenSyntax NameTok, ParsedTokenSyntax Colon, ParsedSyntax StringOrDeclname, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::NamedAttributeStringArgument, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    NameTok.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    StringOrDeclname.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedNamedAttributeStringArgumentSyntax(std::move(raw));
}

ParsedNamedAttributeStringArgumentSyntax
ParsedSyntaxRecorder::makeNamedAttributeStringArgument(ParsedTokenSyntax NameTok, ParsedTokenSyntax Colon, ParsedSyntax StringOrDeclname,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferNamedAttributeStringArgument(std::move(NameTok), std::move(Colon), std::move(StringOrDeclname), SPCtx);
  return recordNamedAttributeStringArgument(std::move(NameTok), std::move(Colon), std::move(StringOrDeclname), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDeclNameSyntax
ParsedSyntaxRecorder::recordDeclName(ParsedSyntax DeclBaseName, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DeclName, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclBaseName.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclNameArguments.hasValue() ? DeclNameArguments->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDeclNameSyntax(std::move(raw));
}

ParsedDeclNameSyntax
ParsedSyntaxRecorder::deferDeclName(ParsedSyntax DeclBaseName, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DeclName, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclBaseName.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclNameArguments.hasValue() ? DeclNameArguments->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDeclNameSyntax(std::move(raw));
}

ParsedDeclNameSyntax
ParsedSyntaxRecorder::makeDeclName(ParsedSyntax DeclBaseName, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDeclName(std::move(DeclBaseName), std::move(DeclNameArguments), SPCtx);
  return recordDeclName(std::move(DeclBaseName), std::move(DeclNameArguments), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedImplementsAttributeArgumentsSyntax
ParsedSyntaxRecorder::recordImplementsAttributeArguments(ParsedSimpleTypeIdentifierSyntax Type, ParsedTokenSyntax Comma, ParsedSyntax DeclBaseName, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ImplementsAttributeArguments, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Comma.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclBaseName.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclNameArguments.hasValue() ? DeclNameArguments->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedImplementsAttributeArgumentsSyntax(std::move(raw));
}

ParsedImplementsAttributeArgumentsSyntax
ParsedSyntaxRecorder::deferImplementsAttributeArguments(ParsedSimpleTypeIdentifierSyntax Type, ParsedTokenSyntax Comma, ParsedSyntax DeclBaseName, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ImplementsAttributeArguments, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Comma.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclBaseName.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeclNameArguments.hasValue() ? DeclNameArguments->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedImplementsAttributeArgumentsSyntax(std::move(raw));
}

ParsedImplementsAttributeArgumentsSyntax
ParsedSyntaxRecorder::makeImplementsAttributeArguments(ParsedSimpleTypeIdentifierSyntax Type, ParsedTokenSyntax Comma, ParsedSyntax DeclBaseName, Optional<ParsedDeclNameArgumentsSyntax> DeclNameArguments,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferImplementsAttributeArguments(std::move(Type), std::move(Comma), std::move(DeclBaseName), std::move(DeclNameArguments), SPCtx);
  return recordImplementsAttributeArguments(std::move(Type), std::move(Comma), std::move(DeclBaseName), std::move(DeclNameArguments), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedObjCSelectorPieceSyntax
ParsedSyntaxRecorder::recordObjCSelectorPiece(Optional<ParsedTokenSyntax> Name, Optional<ParsedTokenSyntax> Colon,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ObjCSelectorPiece, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.hasValue() ? Name->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedObjCSelectorPieceSyntax(std::move(raw));
}

ParsedObjCSelectorPieceSyntax
ParsedSyntaxRecorder::deferObjCSelectorPiece(Optional<ParsedTokenSyntax> Name, Optional<ParsedTokenSyntax> Colon, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ObjCSelectorPiece, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.hasValue() ? Name->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedObjCSelectorPieceSyntax(std::move(raw));
}

ParsedObjCSelectorPieceSyntax
ParsedSyntaxRecorder::makeObjCSelectorPiece(Optional<ParsedTokenSyntax> Name, Optional<ParsedTokenSyntax> Colon,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferObjCSelectorPiece(std::move(Name), std::move(Colon), SPCtx);
  return recordObjCSelectorPiece(std::move(Name), std::move(Colon), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedObjCSelectorSyntax
ParsedSyntaxRecorder::recordObjCSelector(
    ArrayRef<ParsedObjCSelectorPieceSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::ObjCSelector, layout);
  return ParsedObjCSelectorSyntax(std::move(raw));
}

ParsedObjCSelectorSyntax
ParsedSyntaxRecorder::deferObjCSelector(
    ArrayRef<ParsedObjCSelectorPieceSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ObjCSelector,
                             layout, SPCtx);
  return ParsedObjCSelectorSyntax(std::move(raw));
}

ParsedObjCSelectorSyntax
ParsedSyntaxRecorder::makeObjCSelector(
    ArrayRef<ParsedObjCSelectorPieceSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferObjCSelector(elements, SPCtx);
  return recordObjCSelector(elements, SPCtx.getRecorder());
}

ParsedObjCSelectorSyntax
ParsedSyntaxRecorder::makeBlankObjCSelector(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ObjCSelector, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::ObjCSelector, loc);
  }
  return ParsedObjCSelectorSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedContinueStmtSyntax
ParsedSyntaxRecorder::recordContinueStmt(ParsedTokenSyntax ContinueKeyword, Optional<ParsedTokenSyntax> Label,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ContinueStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ContinueKeyword.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.hasValue() ? Label->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedContinueStmtSyntax(std::move(raw));
}

ParsedContinueStmtSyntax
ParsedSyntaxRecorder::deferContinueStmt(ParsedTokenSyntax ContinueKeyword, Optional<ParsedTokenSyntax> Label, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ContinueStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ContinueKeyword.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.hasValue() ? Label->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedContinueStmtSyntax(std::move(raw));
}

ParsedContinueStmtSyntax
ParsedSyntaxRecorder::makeContinueStmt(ParsedTokenSyntax ContinueKeyword, Optional<ParsedTokenSyntax> Label,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferContinueStmt(std::move(ContinueKeyword), std::move(Label), SPCtx);
  return recordContinueStmt(std::move(ContinueKeyword), std::move(Label), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedWhileStmtSyntax
ParsedSyntaxRecorder::recordWhileStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax WhileKeyword, ParsedConditionElementListSyntax Conditions, ParsedCodeBlockSyntax Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::WhileStmt, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhileKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Conditions.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedWhileStmtSyntax(std::move(raw));
}

ParsedWhileStmtSyntax
ParsedSyntaxRecorder::deferWhileStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax WhileKeyword, ParsedConditionElementListSyntax Conditions, ParsedCodeBlockSyntax Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::WhileStmt, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhileKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Conditions.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedWhileStmtSyntax(std::move(raw));
}

ParsedWhileStmtSyntax
ParsedSyntaxRecorder::makeWhileStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax WhileKeyword, ParsedConditionElementListSyntax Conditions, ParsedCodeBlockSyntax Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferWhileStmt(std::move(LabelName), std::move(LabelColon), std::move(WhileKeyword), std::move(Conditions), std::move(Body), SPCtx);
  return recordWhileStmt(std::move(LabelName), std::move(LabelColon), std::move(WhileKeyword), std::move(Conditions), std::move(Body), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDeferStmtSyntax
ParsedSyntaxRecorder::recordDeferStmt(ParsedTokenSyntax DeferKeyword, ParsedCodeBlockSyntax Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DeferStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeferKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDeferStmtSyntax(std::move(raw));
}

ParsedDeferStmtSyntax
ParsedSyntaxRecorder::deferDeferStmt(ParsedTokenSyntax DeferKeyword, ParsedCodeBlockSyntax Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DeferStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DeferKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDeferStmtSyntax(std::move(raw));
}

ParsedDeferStmtSyntax
ParsedSyntaxRecorder::makeDeferStmt(ParsedTokenSyntax DeferKeyword, ParsedCodeBlockSyntax Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDeferStmt(std::move(DeferKeyword), std::move(Body), SPCtx);
  return recordDeferStmt(std::move(DeferKeyword), std::move(Body), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedExpressionStmtSyntax
ParsedSyntaxRecorder::recordExpressionStmt(ParsedExprSyntax Expression,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ExpressionStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedExpressionStmtSyntax(std::move(raw));
}

ParsedExpressionStmtSyntax
ParsedSyntaxRecorder::deferExpressionStmt(ParsedExprSyntax Expression, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ExpressionStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedExpressionStmtSyntax(std::move(raw));
}

ParsedExpressionStmtSyntax
ParsedSyntaxRecorder::makeExpressionStmt(ParsedExprSyntax Expression,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferExpressionStmt(std::move(Expression), SPCtx);
  return recordExpressionStmt(std::move(Expression), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSwitchCaseListSyntax
ParsedSyntaxRecorder::recordSwitchCaseList(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::SwitchCaseList, layout);
  return ParsedSwitchCaseListSyntax(std::move(raw));
}

ParsedSwitchCaseListSyntax
ParsedSyntaxRecorder::deferSwitchCaseList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SwitchCaseList,
                             layout, SPCtx);
  return ParsedSwitchCaseListSyntax(std::move(raw));
}

ParsedSwitchCaseListSyntax
ParsedSyntaxRecorder::makeSwitchCaseList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSwitchCaseList(elements, SPCtx);
  return recordSwitchCaseList(elements, SPCtx.getRecorder());
}

ParsedSwitchCaseListSyntax
ParsedSyntaxRecorder::makeBlankSwitchCaseList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SwitchCaseList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::SwitchCaseList, loc);
  }
  return ParsedSwitchCaseListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedRepeatWhileStmtSyntax
ParsedSyntaxRecorder::recordRepeatWhileStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax RepeatKeyword, ParsedCodeBlockSyntax Body, ParsedTokenSyntax WhileKeyword, ParsedExprSyntax Condition,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::RepeatWhileStmt, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RepeatKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhileKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Condition.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedRepeatWhileStmtSyntax(std::move(raw));
}

ParsedRepeatWhileStmtSyntax
ParsedSyntaxRecorder::deferRepeatWhileStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax RepeatKeyword, ParsedCodeBlockSyntax Body, ParsedTokenSyntax WhileKeyword, ParsedExprSyntax Condition, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::RepeatWhileStmt, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RepeatKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhileKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Condition.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedRepeatWhileStmtSyntax(std::move(raw));
}

ParsedRepeatWhileStmtSyntax
ParsedSyntaxRecorder::makeRepeatWhileStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax RepeatKeyword, ParsedCodeBlockSyntax Body, ParsedTokenSyntax WhileKeyword, ParsedExprSyntax Condition,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferRepeatWhileStmt(std::move(LabelName), std::move(LabelColon), std::move(RepeatKeyword), std::move(Body), std::move(WhileKeyword), std::move(Condition), SPCtx);
  return recordRepeatWhileStmt(std::move(LabelName), std::move(LabelColon), std::move(RepeatKeyword), std::move(Body), std::move(WhileKeyword), std::move(Condition), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedGuardStmtSyntax
ParsedSyntaxRecorder::recordGuardStmt(ParsedTokenSyntax GuardKeyword, ParsedConditionElementListSyntax Conditions, ParsedTokenSyntax ElseKeyword, ParsedCodeBlockSyntax Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::GuardStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GuardKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Conditions.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElseKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedGuardStmtSyntax(std::move(raw));
}

ParsedGuardStmtSyntax
ParsedSyntaxRecorder::deferGuardStmt(ParsedTokenSyntax GuardKeyword, ParsedConditionElementListSyntax Conditions, ParsedTokenSyntax ElseKeyword, ParsedCodeBlockSyntax Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GuardStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GuardKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Conditions.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElseKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedGuardStmtSyntax(std::move(raw));
}

ParsedGuardStmtSyntax
ParsedSyntaxRecorder::makeGuardStmt(ParsedTokenSyntax GuardKeyword, ParsedConditionElementListSyntax Conditions, ParsedTokenSyntax ElseKeyword, ParsedCodeBlockSyntax Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferGuardStmt(std::move(GuardKeyword), std::move(Conditions), std::move(ElseKeyword), std::move(Body), SPCtx);
  return recordGuardStmt(std::move(GuardKeyword), std::move(Conditions), std::move(ElseKeyword), std::move(Body), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedWhereClauseSyntax
ParsedSyntaxRecorder::recordWhereClause(ParsedTokenSyntax WhereKeyword, ParsedExprSyntax GuardResult,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::WhereClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GuardResult.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedWhereClauseSyntax(std::move(raw));
}

ParsedWhereClauseSyntax
ParsedSyntaxRecorder::deferWhereClause(ParsedTokenSyntax WhereKeyword, ParsedExprSyntax GuardResult, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::WhereClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GuardResult.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedWhereClauseSyntax(std::move(raw));
}

ParsedWhereClauseSyntax
ParsedSyntaxRecorder::makeWhereClause(ParsedTokenSyntax WhereKeyword, ParsedExprSyntax GuardResult,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferWhereClause(std::move(WhereKeyword), std::move(GuardResult), SPCtx);
  return recordWhereClause(std::move(WhereKeyword), std::move(GuardResult), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedForInStmtSyntax
ParsedSyntaxRecorder::recordForInStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax ForKeyword, Optional<ParsedTokenSyntax> CaseKeyword, ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, ParsedTokenSyntax InKeyword, ParsedExprSyntax SequenceExpr, Optional<ParsedWhereClauseSyntax> WhereClause, ParsedCodeBlockSyntax Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ForInStmt, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ForKeyword.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseKeyword.hasValue() ? CaseKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SequenceExpr.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereClause.hasValue() ? WhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedForInStmtSyntax(std::move(raw));
}

ParsedForInStmtSyntax
ParsedSyntaxRecorder::deferForInStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax ForKeyword, Optional<ParsedTokenSyntax> CaseKeyword, ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, ParsedTokenSyntax InKeyword, ParsedExprSyntax SequenceExpr, Optional<ParsedWhereClauseSyntax> WhereClause, ParsedCodeBlockSyntax Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ForInStmt, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ForKeyword.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseKeyword.hasValue() ? CaseKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SequenceExpr.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereClause.hasValue() ? WhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedForInStmtSyntax(std::move(raw));
}

ParsedForInStmtSyntax
ParsedSyntaxRecorder::makeForInStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax ForKeyword, Optional<ParsedTokenSyntax> CaseKeyword, ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, ParsedTokenSyntax InKeyword, ParsedExprSyntax SequenceExpr, Optional<ParsedWhereClauseSyntax> WhereClause, ParsedCodeBlockSyntax Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferForInStmt(std::move(LabelName), std::move(LabelColon), std::move(ForKeyword), std::move(CaseKeyword), std::move(Pattern), std::move(TypeAnnotation), std::move(InKeyword), std::move(SequenceExpr), std::move(WhereClause), std::move(Body), SPCtx);
  return recordForInStmt(std::move(LabelName), std::move(LabelColon), std::move(ForKeyword), std::move(CaseKeyword), std::move(Pattern), std::move(TypeAnnotation), std::move(InKeyword), std::move(SequenceExpr), std::move(WhereClause), std::move(Body), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSwitchStmtSyntax
ParsedSyntaxRecorder::recordSwitchStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax SwitchKeyword, ParsedExprSyntax Expression, ParsedTokenSyntax LeftBrace, ParsedSwitchCaseListSyntax Cases, ParsedTokenSyntax RightBrace,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SwitchStmt, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SwitchKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Cases.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSwitchStmtSyntax(std::move(raw));
}

ParsedSwitchStmtSyntax
ParsedSyntaxRecorder::deferSwitchStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax SwitchKeyword, ParsedExprSyntax Expression, ParsedTokenSyntax LeftBrace, ParsedSwitchCaseListSyntax Cases, ParsedTokenSyntax RightBrace, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SwitchStmt, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SwitchKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftBrace.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Cases.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightBrace.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSwitchStmtSyntax(std::move(raw));
}

ParsedSwitchStmtSyntax
ParsedSyntaxRecorder::makeSwitchStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax SwitchKeyword, ParsedExprSyntax Expression, ParsedTokenSyntax LeftBrace, ParsedSwitchCaseListSyntax Cases, ParsedTokenSyntax RightBrace,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSwitchStmt(std::move(LabelName), std::move(LabelColon), std::move(SwitchKeyword), std::move(Expression), std::move(LeftBrace), std::move(Cases), std::move(RightBrace), SPCtx);
  return recordSwitchStmt(std::move(LabelName), std::move(LabelColon), std::move(SwitchKeyword), std::move(Expression), std::move(LeftBrace), std::move(Cases), std::move(RightBrace), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCatchClauseListSyntax
ParsedSyntaxRecorder::recordCatchClauseList(
    ArrayRef<ParsedCatchClauseSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::CatchClauseList, layout);
  return ParsedCatchClauseListSyntax(std::move(raw));
}

ParsedCatchClauseListSyntax
ParsedSyntaxRecorder::deferCatchClauseList(
    ArrayRef<ParsedCatchClauseSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CatchClauseList,
                             layout, SPCtx);
  return ParsedCatchClauseListSyntax(std::move(raw));
}

ParsedCatchClauseListSyntax
ParsedSyntaxRecorder::makeCatchClauseList(
    ArrayRef<ParsedCatchClauseSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCatchClauseList(elements, SPCtx);
  return recordCatchClauseList(elements, SPCtx.getRecorder());
}

ParsedCatchClauseListSyntax
ParsedSyntaxRecorder::makeBlankCatchClauseList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CatchClauseList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::CatchClauseList, loc);
  }
  return ParsedCatchClauseListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDoStmtSyntax
ParsedSyntaxRecorder::recordDoStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax DoKeyword, ParsedCodeBlockSyntax Body, Optional<ParsedCatchClauseListSyntax> CatchClauses,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DoStmt, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DoKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CatchClauses.hasValue() ? CatchClauses->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDoStmtSyntax(std::move(raw));
}

ParsedDoStmtSyntax
ParsedSyntaxRecorder::deferDoStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax DoKeyword, ParsedCodeBlockSyntax Body, Optional<ParsedCatchClauseListSyntax> CatchClauses, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DoStmt, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DoKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CatchClauses.hasValue() ? CatchClauses->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDoStmtSyntax(std::move(raw));
}

ParsedDoStmtSyntax
ParsedSyntaxRecorder::makeDoStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax DoKeyword, ParsedCodeBlockSyntax Body, Optional<ParsedCatchClauseListSyntax> CatchClauses,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDoStmt(std::move(LabelName), std::move(LabelColon), std::move(DoKeyword), std::move(Body), std::move(CatchClauses), SPCtx);
  return recordDoStmt(std::move(LabelName), std::move(LabelColon), std::move(DoKeyword), std::move(Body), std::move(CatchClauses), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedReturnStmtSyntax
ParsedSyntaxRecorder::recordReturnStmt(ParsedTokenSyntax ReturnKeyword, Optional<ParsedExprSyntax> Expression,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ReturnStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ReturnKeyword.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.hasValue() ? Expression->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedReturnStmtSyntax(std::move(raw));
}

ParsedReturnStmtSyntax
ParsedSyntaxRecorder::deferReturnStmt(ParsedTokenSyntax ReturnKeyword, Optional<ParsedExprSyntax> Expression, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ReturnStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ReturnKeyword.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.hasValue() ? Expression->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedReturnStmtSyntax(std::move(raw));
}

ParsedReturnStmtSyntax
ParsedSyntaxRecorder::makeReturnStmt(ParsedTokenSyntax ReturnKeyword, Optional<ParsedExprSyntax> Expression,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferReturnStmt(std::move(ReturnKeyword), std::move(Expression), SPCtx);
  return recordReturnStmt(std::move(ReturnKeyword), std::move(Expression), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedYieldStmtSyntax
ParsedSyntaxRecorder::recordYieldStmt(ParsedTokenSyntax YieldKeyword, ParsedSyntax Yields,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::YieldStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    YieldKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Yields.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedYieldStmtSyntax(std::move(raw));
}

ParsedYieldStmtSyntax
ParsedSyntaxRecorder::deferYieldStmt(ParsedTokenSyntax YieldKeyword, ParsedSyntax Yields, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::YieldStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    YieldKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Yields.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedYieldStmtSyntax(std::move(raw));
}

ParsedYieldStmtSyntax
ParsedSyntaxRecorder::makeYieldStmt(ParsedTokenSyntax YieldKeyword, ParsedSyntax Yields,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferYieldStmt(std::move(YieldKeyword), std::move(Yields), SPCtx);
  return recordYieldStmt(std::move(YieldKeyword), std::move(Yields), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedYieldListSyntax
ParsedSyntaxRecorder::recordYieldList(ParsedTokenSyntax LeftParen, ParsedExprListSyntax ElementList, Optional<ParsedTokenSyntax> TrailingComma, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::YieldList, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElementList.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedYieldListSyntax(std::move(raw));
}

ParsedYieldListSyntax
ParsedSyntaxRecorder::deferYieldList(ParsedTokenSyntax LeftParen, ParsedExprListSyntax ElementList, Optional<ParsedTokenSyntax> TrailingComma, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::YieldList, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElementList.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedYieldListSyntax(std::move(raw));
}

ParsedYieldListSyntax
ParsedSyntaxRecorder::makeYieldList(ParsedTokenSyntax LeftParen, ParsedExprListSyntax ElementList, Optional<ParsedTokenSyntax> TrailingComma, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferYieldList(std::move(LeftParen), std::move(ElementList), std::move(TrailingComma), std::move(RightParen), SPCtx);
  return recordYieldList(std::move(LeftParen), std::move(ElementList), std::move(TrailingComma), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFallthroughStmtSyntax
ParsedSyntaxRecorder::recordFallthroughStmt(ParsedTokenSyntax FallthroughKeyword,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::FallthroughStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FallthroughKeyword.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedFallthroughStmtSyntax(std::move(raw));
}

ParsedFallthroughStmtSyntax
ParsedSyntaxRecorder::deferFallthroughStmt(ParsedTokenSyntax FallthroughKeyword, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FallthroughStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    FallthroughKeyword.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedFallthroughStmtSyntax(std::move(raw));
}

ParsedFallthroughStmtSyntax
ParsedSyntaxRecorder::makeFallthroughStmt(ParsedTokenSyntax FallthroughKeyword,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFallthroughStmt(std::move(FallthroughKeyword), SPCtx);
  return recordFallthroughStmt(std::move(FallthroughKeyword), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedBreakStmtSyntax
ParsedSyntaxRecorder::recordBreakStmt(ParsedTokenSyntax BreakKeyword, Optional<ParsedTokenSyntax> Label,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::BreakStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BreakKeyword.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.hasValue() ? Label->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedBreakStmtSyntax(std::move(raw));
}

ParsedBreakStmtSyntax
ParsedSyntaxRecorder::deferBreakStmt(ParsedTokenSyntax BreakKeyword, Optional<ParsedTokenSyntax> Label, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::BreakStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BreakKeyword.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.hasValue() ? Label->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedBreakStmtSyntax(std::move(raw));
}

ParsedBreakStmtSyntax
ParsedSyntaxRecorder::makeBreakStmt(ParsedTokenSyntax BreakKeyword, Optional<ParsedTokenSyntax> Label,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferBreakStmt(std::move(BreakKeyword), std::move(Label), SPCtx);
  return recordBreakStmt(std::move(BreakKeyword), std::move(Label), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCaseItemListSyntax
ParsedSyntaxRecorder::recordCaseItemList(
    ArrayRef<ParsedCaseItemSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::CaseItemList, layout);
  return ParsedCaseItemListSyntax(std::move(raw));
}

ParsedCaseItemListSyntax
ParsedSyntaxRecorder::deferCaseItemList(
    ArrayRef<ParsedCaseItemSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CaseItemList,
                             layout, SPCtx);
  return ParsedCaseItemListSyntax(std::move(raw));
}

ParsedCaseItemListSyntax
ParsedSyntaxRecorder::makeCaseItemList(
    ArrayRef<ParsedCaseItemSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCaseItemList(elements, SPCtx);
  return recordCaseItemList(elements, SPCtx.getRecorder());
}

ParsedCaseItemListSyntax
ParsedSyntaxRecorder::makeBlankCaseItemList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CaseItemList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::CaseItemList, loc);
  }
  return ParsedCaseItemListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedConditionElementSyntax
ParsedSyntaxRecorder::recordConditionElement(ParsedSyntax Condition, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ConditionElement, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Condition.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedConditionElementSyntax(std::move(raw));
}

ParsedConditionElementSyntax
ParsedSyntaxRecorder::deferConditionElement(ParsedSyntax Condition, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ConditionElement, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Condition.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedConditionElementSyntax(std::move(raw));
}

ParsedConditionElementSyntax
ParsedSyntaxRecorder::makeConditionElement(ParsedSyntax Condition, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferConditionElement(std::move(Condition), std::move(TrailingComma), SPCtx);
  return recordConditionElement(std::move(Condition), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAvailabilityConditionSyntax
ParsedSyntaxRecorder::recordAvailabilityCondition(ParsedTokenSyntax PoundAvailableKeyword, ParsedTokenSyntax LeftParen, ParsedAvailabilitySpecListSyntax AvailabilitySpec, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AvailabilityCondition, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundAvailableKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AvailabilitySpec.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAvailabilityConditionSyntax(std::move(raw));
}

ParsedAvailabilityConditionSyntax
ParsedSyntaxRecorder::deferAvailabilityCondition(ParsedTokenSyntax PoundAvailableKeyword, ParsedTokenSyntax LeftParen, ParsedAvailabilitySpecListSyntax AvailabilitySpec, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AvailabilityCondition, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundAvailableKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AvailabilitySpec.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAvailabilityConditionSyntax(std::move(raw));
}

ParsedAvailabilityConditionSyntax
ParsedSyntaxRecorder::makeAvailabilityCondition(ParsedTokenSyntax PoundAvailableKeyword, ParsedTokenSyntax LeftParen, ParsedAvailabilitySpecListSyntax AvailabilitySpec, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAvailabilityCondition(std::move(PoundAvailableKeyword), std::move(LeftParen), std::move(AvailabilitySpec), std::move(RightParen), SPCtx);
  return recordAvailabilityCondition(std::move(PoundAvailableKeyword), std::move(LeftParen), std::move(AvailabilitySpec), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedMatchingPatternConditionSyntax
ParsedSyntaxRecorder::recordMatchingPatternCondition(ParsedTokenSyntax CaseKeyword, ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, ParsedInitializerClauseSyntax Initializer,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::MatchingPatternCondition, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedMatchingPatternConditionSyntax(std::move(raw));
}

ParsedMatchingPatternConditionSyntax
ParsedSyntaxRecorder::deferMatchingPatternCondition(ParsedTokenSyntax CaseKeyword, ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, ParsedInitializerClauseSyntax Initializer, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::MatchingPatternCondition, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedMatchingPatternConditionSyntax(std::move(raw));
}

ParsedMatchingPatternConditionSyntax
ParsedSyntaxRecorder::makeMatchingPatternCondition(ParsedTokenSyntax CaseKeyword, ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, ParsedInitializerClauseSyntax Initializer,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferMatchingPatternCondition(std::move(CaseKeyword), std::move(Pattern), std::move(TypeAnnotation), std::move(Initializer), SPCtx);
  return recordMatchingPatternCondition(std::move(CaseKeyword), std::move(Pattern), std::move(TypeAnnotation), std::move(Initializer), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedOptionalBindingConditionSyntax
ParsedSyntaxRecorder::recordOptionalBindingCondition(ParsedTokenSyntax LetOrVarKeyword, ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, ParsedInitializerClauseSyntax Initializer,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::OptionalBindingCondition, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LetOrVarKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedOptionalBindingConditionSyntax(std::move(raw));
}

ParsedOptionalBindingConditionSyntax
ParsedSyntaxRecorder::deferOptionalBindingCondition(ParsedTokenSyntax LetOrVarKeyword, ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, ParsedInitializerClauseSyntax Initializer, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::OptionalBindingCondition, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LetOrVarKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedOptionalBindingConditionSyntax(std::move(raw));
}

ParsedOptionalBindingConditionSyntax
ParsedSyntaxRecorder::makeOptionalBindingCondition(ParsedTokenSyntax LetOrVarKeyword, ParsedPatternSyntax Pattern, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, ParsedInitializerClauseSyntax Initializer,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferOptionalBindingCondition(std::move(LetOrVarKeyword), std::move(Pattern), std::move(TypeAnnotation), std::move(Initializer), SPCtx);
  return recordOptionalBindingCondition(std::move(LetOrVarKeyword), std::move(Pattern), std::move(TypeAnnotation), std::move(Initializer), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedConditionElementListSyntax
ParsedSyntaxRecorder::recordConditionElementList(
    ArrayRef<ParsedConditionElementSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::ConditionElementList, layout);
  return ParsedConditionElementListSyntax(std::move(raw));
}

ParsedConditionElementListSyntax
ParsedSyntaxRecorder::deferConditionElementList(
    ArrayRef<ParsedConditionElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ConditionElementList,
                             layout, SPCtx);
  return ParsedConditionElementListSyntax(std::move(raw));
}

ParsedConditionElementListSyntax
ParsedSyntaxRecorder::makeConditionElementList(
    ArrayRef<ParsedConditionElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferConditionElementList(elements, SPCtx);
  return recordConditionElementList(elements, SPCtx.getRecorder());
}

ParsedConditionElementListSyntax
ParsedSyntaxRecorder::makeBlankConditionElementList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ConditionElementList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::ConditionElementList, loc);
  }
  return ParsedConditionElementListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDeclarationStmtSyntax
ParsedSyntaxRecorder::recordDeclarationStmt(ParsedDeclSyntax Declaration,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DeclarationStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Declaration.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDeclarationStmtSyntax(std::move(raw));
}

ParsedDeclarationStmtSyntax
ParsedSyntaxRecorder::deferDeclarationStmt(ParsedDeclSyntax Declaration, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DeclarationStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Declaration.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDeclarationStmtSyntax(std::move(raw));
}

ParsedDeclarationStmtSyntax
ParsedSyntaxRecorder::makeDeclarationStmt(ParsedDeclSyntax Declaration,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDeclarationStmt(std::move(Declaration), SPCtx);
  return recordDeclarationStmt(std::move(Declaration), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedThrowStmtSyntax
ParsedSyntaxRecorder::recordThrowStmt(ParsedTokenSyntax ThrowKeyword, ParsedExprSyntax Expression,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ThrowStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedThrowStmtSyntax(std::move(raw));
}

ParsedThrowStmtSyntax
ParsedSyntaxRecorder::deferThrowStmt(ParsedTokenSyntax ThrowKeyword, ParsedExprSyntax Expression, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ThrowStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedThrowStmtSyntax(std::move(raw));
}

ParsedThrowStmtSyntax
ParsedSyntaxRecorder::makeThrowStmt(ParsedTokenSyntax ThrowKeyword, ParsedExprSyntax Expression,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferThrowStmt(std::move(ThrowKeyword), std::move(Expression), SPCtx);
  return recordThrowStmt(std::move(ThrowKeyword), std::move(Expression), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIfStmtSyntax
ParsedSyntaxRecorder::recordIfStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax IfKeyword, ParsedConditionElementListSyntax Conditions, ParsedCodeBlockSyntax Body, Optional<ParsedTokenSyntax> ElseKeyword, Optional<ParsedSyntax> ElseBody,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::IfStmt, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    IfKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Conditions.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElseKeyword.hasValue() ? ElseKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElseBody.hasValue() ? ElseBody->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedIfStmtSyntax(std::move(raw));
}

ParsedIfStmtSyntax
ParsedSyntaxRecorder::deferIfStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax IfKeyword, ParsedConditionElementListSyntax Conditions, ParsedCodeBlockSyntax Body, Optional<ParsedTokenSyntax> ElseKeyword, Optional<ParsedSyntax> ElseBody, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IfStmt, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    IfKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Conditions.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElseKeyword.hasValue() ? ElseKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElseBody.hasValue() ? ElseBody->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedIfStmtSyntax(std::move(raw));
}

ParsedIfStmtSyntax
ParsedSyntaxRecorder::makeIfStmt(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedTokenSyntax IfKeyword, ParsedConditionElementListSyntax Conditions, ParsedCodeBlockSyntax Body, Optional<ParsedTokenSyntax> ElseKeyword, Optional<ParsedSyntax> ElseBody,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIfStmt(std::move(LabelName), std::move(LabelColon), std::move(IfKeyword), std::move(Conditions), std::move(Body), std::move(ElseKeyword), std::move(ElseBody), SPCtx);
  return recordIfStmt(std::move(LabelName), std::move(LabelColon), std::move(IfKeyword), std::move(Conditions), std::move(Body), std::move(ElseKeyword), std::move(ElseBody), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedElseIfContinuationSyntax
ParsedSyntaxRecorder::recordElseIfContinuation(ParsedIfStmtSyntax IfStatement,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ElseIfContinuation, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    IfStatement.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedElseIfContinuationSyntax(std::move(raw));
}

ParsedElseIfContinuationSyntax
ParsedSyntaxRecorder::deferElseIfContinuation(ParsedIfStmtSyntax IfStatement, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ElseIfContinuation, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    IfStatement.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedElseIfContinuationSyntax(std::move(raw));
}

ParsedElseIfContinuationSyntax
ParsedSyntaxRecorder::makeElseIfContinuation(ParsedIfStmtSyntax IfStatement,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferElseIfContinuation(std::move(IfStatement), SPCtx);
  return recordElseIfContinuation(std::move(IfStatement), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedElseBlockSyntax
ParsedSyntaxRecorder::recordElseBlock(ParsedTokenSyntax ElseKeyword, ParsedCodeBlockSyntax Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ElseBlock, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElseKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedElseBlockSyntax(std::move(raw));
}

ParsedElseBlockSyntax
ParsedSyntaxRecorder::deferElseBlock(ParsedTokenSyntax ElseKeyword, ParsedCodeBlockSyntax Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ElseBlock, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElseKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedElseBlockSyntax(std::move(raw));
}

ParsedElseBlockSyntax
ParsedSyntaxRecorder::makeElseBlock(ParsedTokenSyntax ElseKeyword, ParsedCodeBlockSyntax Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferElseBlock(std::move(ElseKeyword), std::move(Body), SPCtx);
  return recordElseBlock(std::move(ElseKeyword), std::move(Body), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSwitchCaseSyntax
ParsedSyntaxRecorder::recordSwitchCase(Optional<ParsedAttributeSyntax> UnknownAttr, ParsedSyntax Label, ParsedCodeBlockItemListSyntax Statements,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SwitchCase, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    UnknownAttr.hasValue() ? UnknownAttr->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Statements.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSwitchCaseSyntax(std::move(raw));
}

ParsedSwitchCaseSyntax
ParsedSyntaxRecorder::deferSwitchCase(Optional<ParsedAttributeSyntax> UnknownAttr, ParsedSyntax Label, ParsedCodeBlockItemListSyntax Statements, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SwitchCase, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    UnknownAttr.hasValue() ? UnknownAttr->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Statements.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSwitchCaseSyntax(std::move(raw));
}

ParsedSwitchCaseSyntax
ParsedSyntaxRecorder::makeSwitchCase(Optional<ParsedAttributeSyntax> UnknownAttr, ParsedSyntax Label, ParsedCodeBlockItemListSyntax Statements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSwitchCase(std::move(UnknownAttr), std::move(Label), std::move(Statements), SPCtx);
  return recordSwitchCase(std::move(UnknownAttr), std::move(Label), std::move(Statements), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSwitchDefaultLabelSyntax
ParsedSyntaxRecorder::recordSwitchDefaultLabel(ParsedTokenSyntax DefaultKeyword, ParsedTokenSyntax Colon,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SwitchDefaultLabel, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DefaultKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSwitchDefaultLabelSyntax(std::move(raw));
}

ParsedSwitchDefaultLabelSyntax
ParsedSyntaxRecorder::deferSwitchDefaultLabel(ParsedTokenSyntax DefaultKeyword, ParsedTokenSyntax Colon, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SwitchDefaultLabel, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    DefaultKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSwitchDefaultLabelSyntax(std::move(raw));
}

ParsedSwitchDefaultLabelSyntax
ParsedSyntaxRecorder::makeSwitchDefaultLabel(ParsedTokenSyntax DefaultKeyword, ParsedTokenSyntax Colon,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSwitchDefaultLabel(std::move(DefaultKeyword), std::move(Colon), SPCtx);
  return recordSwitchDefaultLabel(std::move(DefaultKeyword), std::move(Colon), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCaseItemSyntax
ParsedSyntaxRecorder::recordCaseItem(ParsedPatternSyntax Pattern, Optional<ParsedWhereClauseSyntax> WhereClause, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::CaseItem, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereClause.hasValue() ? WhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedCaseItemSyntax(std::move(raw));
}

ParsedCaseItemSyntax
ParsedSyntaxRecorder::deferCaseItem(ParsedPatternSyntax Pattern, Optional<ParsedWhereClauseSyntax> WhereClause, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CaseItem, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereClause.hasValue() ? WhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedCaseItemSyntax(std::move(raw));
}

ParsedCaseItemSyntax
ParsedSyntaxRecorder::makeCaseItem(ParsedPatternSyntax Pattern, Optional<ParsedWhereClauseSyntax> WhereClause, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCaseItem(std::move(Pattern), std::move(WhereClause), std::move(TrailingComma), SPCtx);
  return recordCaseItem(std::move(Pattern), std::move(WhereClause), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSwitchCaseLabelSyntax
ParsedSyntaxRecorder::recordSwitchCaseLabel(ParsedTokenSyntax CaseKeyword, ParsedCaseItemListSyntax CaseItems, ParsedTokenSyntax Colon,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SwitchCaseLabel, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseItems.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSwitchCaseLabelSyntax(std::move(raw));
}

ParsedSwitchCaseLabelSyntax
ParsedSyntaxRecorder::deferSwitchCaseLabel(ParsedTokenSyntax CaseKeyword, ParsedCaseItemListSyntax CaseItems, ParsedTokenSyntax Colon, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SwitchCaseLabel, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseItems.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSwitchCaseLabelSyntax(std::move(raw));
}

ParsedSwitchCaseLabelSyntax
ParsedSyntaxRecorder::makeSwitchCaseLabel(ParsedTokenSyntax CaseKeyword, ParsedCaseItemListSyntax CaseItems, ParsedTokenSyntax Colon,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSwitchCaseLabel(std::move(CaseKeyword), std::move(CaseItems), std::move(Colon), SPCtx);
  return recordSwitchCaseLabel(std::move(CaseKeyword), std::move(CaseItems), std::move(Colon), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCatchClauseSyntax
ParsedSyntaxRecorder::recordCatchClause(ParsedTokenSyntax CatchKeyword, Optional<ParsedPatternSyntax> Pattern, Optional<ParsedWhereClauseSyntax> WhereClause, ParsedCodeBlockSyntax Body,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::CatchClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CatchKeyword.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.hasValue() ? Pattern->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereClause.hasValue() ? WhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedCatchClauseSyntax(std::move(raw));
}

ParsedCatchClauseSyntax
ParsedSyntaxRecorder::deferCatchClause(ParsedTokenSyntax CatchKeyword, Optional<ParsedPatternSyntax> Pattern, Optional<ParsedWhereClauseSyntax> WhereClause, ParsedCodeBlockSyntax Body, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CatchClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CatchKeyword.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.hasValue() ? Pattern->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereClause.hasValue() ? WhereClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Body.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedCatchClauseSyntax(std::move(raw));
}

ParsedCatchClauseSyntax
ParsedSyntaxRecorder::makeCatchClause(ParsedTokenSyntax CatchKeyword, Optional<ParsedPatternSyntax> Pattern, Optional<ParsedWhereClauseSyntax> WhereClause, ParsedCodeBlockSyntax Body,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCatchClause(std::move(CatchKeyword), std::move(Pattern), std::move(WhereClause), std::move(Body), SPCtx);
  return recordCatchClause(std::move(CatchKeyword), std::move(Pattern), std::move(WhereClause), std::move(Body), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedPoundAssertStmtSyntax
ParsedSyntaxRecorder::recordPoundAssertStmt(ParsedTokenSyntax PoundAssert, ParsedTokenSyntax LeftParen, ParsedExprSyntax Condition, Optional<ParsedTokenSyntax> Comma, Optional<ParsedTokenSyntax> Message, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::PoundAssertStmt, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundAssert.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Condition.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Comma.hasValue() ? Comma->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Message.hasValue() ? Message->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedPoundAssertStmtSyntax(std::move(raw));
}

ParsedPoundAssertStmtSyntax
ParsedSyntaxRecorder::deferPoundAssertStmt(ParsedTokenSyntax PoundAssert, ParsedTokenSyntax LeftParen, ParsedExprSyntax Condition, Optional<ParsedTokenSyntax> Comma, Optional<ParsedTokenSyntax> Message, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::PoundAssertStmt, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PoundAssert.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Condition.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Comma.hasValue() ? Comma->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Message.hasValue() ? Message->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedPoundAssertStmtSyntax(std::move(raw));
}

ParsedPoundAssertStmtSyntax
ParsedSyntaxRecorder::makePoundAssertStmt(ParsedTokenSyntax PoundAssert, ParsedTokenSyntax LeftParen, ParsedExprSyntax Condition, Optional<ParsedTokenSyntax> Comma, Optional<ParsedTokenSyntax> Message, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferPoundAssertStmt(std::move(PoundAssert), std::move(LeftParen), std::move(Condition), std::move(Comma), std::move(Message), std::move(RightParen), SPCtx);
  return recordPoundAssertStmt(std::move(PoundAssert), std::move(LeftParen), std::move(Condition), std::move(Comma), std::move(Message), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedGenericWhereClauseSyntax
ParsedSyntaxRecorder::recordGenericWhereClause(ParsedTokenSyntax WhereKeyword, ParsedGenericRequirementListSyntax RequirementList,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::GenericWhereClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RequirementList.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedGenericWhereClauseSyntax(std::move(raw));
}

ParsedGenericWhereClauseSyntax
ParsedSyntaxRecorder::deferGenericWhereClause(ParsedTokenSyntax WhereKeyword, ParsedGenericRequirementListSyntax RequirementList, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericWhereClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WhereKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RequirementList.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedGenericWhereClauseSyntax(std::move(raw));
}

ParsedGenericWhereClauseSyntax
ParsedSyntaxRecorder::makeGenericWhereClause(ParsedTokenSyntax WhereKeyword, ParsedGenericRequirementListSyntax RequirementList,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferGenericWhereClause(std::move(WhereKeyword), std::move(RequirementList), SPCtx);
  return recordGenericWhereClause(std::move(WhereKeyword), std::move(RequirementList), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedGenericRequirementListSyntax
ParsedSyntaxRecorder::recordGenericRequirementList(
    ArrayRef<ParsedSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::GenericRequirementList, layout);
  return ParsedGenericRequirementListSyntax(std::move(raw));
}

ParsedGenericRequirementListSyntax
ParsedSyntaxRecorder::deferGenericRequirementList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericRequirementList,
                             layout, SPCtx);
  return ParsedGenericRequirementListSyntax(std::move(raw));
}

ParsedGenericRequirementListSyntax
ParsedSyntaxRecorder::makeGenericRequirementList(
    ArrayRef<ParsedSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferGenericRequirementList(elements, SPCtx);
  return recordGenericRequirementList(elements, SPCtx.getRecorder());
}

ParsedGenericRequirementListSyntax
ParsedSyntaxRecorder::makeBlankGenericRequirementList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericRequirementList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::GenericRequirementList, loc);
  }
  return ParsedGenericRequirementListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSameTypeRequirementSyntax
ParsedSyntaxRecorder::recordSameTypeRequirement(ParsedTypeSyntax LeftTypeIdentifier, ParsedTokenSyntax EqualityToken, ParsedTypeSyntax RightTypeIdentifier, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SameTypeRequirement, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftTypeIdentifier.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    EqualityToken.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightTypeIdentifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSameTypeRequirementSyntax(std::move(raw));
}

ParsedSameTypeRequirementSyntax
ParsedSyntaxRecorder::deferSameTypeRequirement(ParsedTypeSyntax LeftTypeIdentifier, ParsedTokenSyntax EqualityToken, ParsedTypeSyntax RightTypeIdentifier, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SameTypeRequirement, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftTypeIdentifier.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    EqualityToken.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightTypeIdentifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSameTypeRequirementSyntax(std::move(raw));
}

ParsedSameTypeRequirementSyntax
ParsedSyntaxRecorder::makeSameTypeRequirement(ParsedTypeSyntax LeftTypeIdentifier, ParsedTokenSyntax EqualityToken, ParsedTypeSyntax RightTypeIdentifier, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSameTypeRequirement(std::move(LeftTypeIdentifier), std::move(EqualityToken), std::move(RightTypeIdentifier), std::move(TrailingComma), SPCtx);
  return recordSameTypeRequirement(std::move(LeftTypeIdentifier), std::move(EqualityToken), std::move(RightTypeIdentifier), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedGenericParameterListSyntax
ParsedSyntaxRecorder::recordGenericParameterList(
    ArrayRef<ParsedGenericParameterSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::GenericParameterList, layout);
  return ParsedGenericParameterListSyntax(std::move(raw));
}

ParsedGenericParameterListSyntax
ParsedSyntaxRecorder::deferGenericParameterList(
    ArrayRef<ParsedGenericParameterSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericParameterList,
                             layout, SPCtx);
  return ParsedGenericParameterListSyntax(std::move(raw));
}

ParsedGenericParameterListSyntax
ParsedSyntaxRecorder::makeGenericParameterList(
    ArrayRef<ParsedGenericParameterSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferGenericParameterList(elements, SPCtx);
  return recordGenericParameterList(elements, SPCtx.getRecorder());
}

ParsedGenericParameterListSyntax
ParsedSyntaxRecorder::makeBlankGenericParameterList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericParameterList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::GenericParameterList, loc);
  }
  return ParsedGenericParameterListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedGenericParameterSyntax
ParsedSyntaxRecorder::recordGenericParameter(Optional<ParsedAttributeListSyntax> Attributes, ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> Colon, Optional<ParsedTypeSyntax> InheritedType, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::GenericParameter, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritedType.hasValue() ? InheritedType->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedGenericParameterSyntax(std::move(raw));
}

ParsedGenericParameterSyntax
ParsedSyntaxRecorder::deferGenericParameter(Optional<ParsedAttributeListSyntax> Attributes, ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> Colon, Optional<ParsedTypeSyntax> InheritedType, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericParameter, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InheritedType.hasValue() ? InheritedType->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedGenericParameterSyntax(std::move(raw));
}

ParsedGenericParameterSyntax
ParsedSyntaxRecorder::makeGenericParameter(Optional<ParsedAttributeListSyntax> Attributes, ParsedTokenSyntax Name, Optional<ParsedTokenSyntax> Colon, Optional<ParsedTypeSyntax> InheritedType, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferGenericParameter(std::move(Attributes), std::move(Name), std::move(Colon), std::move(InheritedType), std::move(TrailingComma), SPCtx);
  return recordGenericParameter(std::move(Attributes), std::move(Name), std::move(Colon), std::move(InheritedType), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedGenericParameterClauseSyntax
ParsedSyntaxRecorder::recordGenericParameterClause(ParsedTokenSyntax LeftAngleBracket, ParsedGenericParameterListSyntax GenericParameterList, ParsedTokenSyntax RightAngleBracket,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::GenericParameterClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftAngleBracket.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterList.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightAngleBracket.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedGenericParameterClauseSyntax(std::move(raw));
}

ParsedGenericParameterClauseSyntax
ParsedSyntaxRecorder::deferGenericParameterClause(ParsedTokenSyntax LeftAngleBracket, ParsedGenericParameterListSyntax GenericParameterList, ParsedTokenSyntax RightAngleBracket, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericParameterClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftAngleBracket.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericParameterList.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightAngleBracket.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedGenericParameterClauseSyntax(std::move(raw));
}

ParsedGenericParameterClauseSyntax
ParsedSyntaxRecorder::makeGenericParameterClause(ParsedTokenSyntax LeftAngleBracket, ParsedGenericParameterListSyntax GenericParameterList, ParsedTokenSyntax RightAngleBracket,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferGenericParameterClause(std::move(LeftAngleBracket), std::move(GenericParameterList), std::move(RightAngleBracket), SPCtx);
  return recordGenericParameterClause(std::move(LeftAngleBracket), std::move(GenericParameterList), std::move(RightAngleBracket), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedConformanceRequirementSyntax
ParsedSyntaxRecorder::recordConformanceRequirement(ParsedTypeSyntax LeftTypeIdentifier, ParsedTokenSyntax Colon, ParsedTypeSyntax RightTypeIdentifier, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ConformanceRequirement, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftTypeIdentifier.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightTypeIdentifier.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedConformanceRequirementSyntax(std::move(raw));
}

ParsedConformanceRequirementSyntax
ParsedSyntaxRecorder::deferConformanceRequirement(ParsedTypeSyntax LeftTypeIdentifier, ParsedTokenSyntax Colon, ParsedTypeSyntax RightTypeIdentifier, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ConformanceRequirement, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftTypeIdentifier.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightTypeIdentifier.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedConformanceRequirementSyntax(std::move(raw));
}

ParsedConformanceRequirementSyntax
ParsedSyntaxRecorder::makeConformanceRequirement(ParsedTypeSyntax LeftTypeIdentifier, ParsedTokenSyntax Colon, ParsedTypeSyntax RightTypeIdentifier, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferConformanceRequirement(std::move(LeftTypeIdentifier), std::move(Colon), std::move(RightTypeIdentifier), std::move(TrailingComma), SPCtx);
  return recordConformanceRequirement(std::move(LeftTypeIdentifier), std::move(Colon), std::move(RightTypeIdentifier), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSimpleTypeIdentifierSyntax
ParsedSyntaxRecorder::recordSimpleTypeIdentifier(ParsedTokenSyntax Name, Optional<ParsedGenericArgumentClauseSyntax> GenericArgumentClause,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SimpleTypeIdentifier, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericArgumentClause.hasValue() ? GenericArgumentClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSimpleTypeIdentifierSyntax(std::move(raw));
}

ParsedSimpleTypeIdentifierSyntax
ParsedSyntaxRecorder::deferSimpleTypeIdentifier(ParsedTokenSyntax Name, Optional<ParsedGenericArgumentClauseSyntax> GenericArgumentClause, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SimpleTypeIdentifier, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericArgumentClause.hasValue() ? GenericArgumentClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSimpleTypeIdentifierSyntax(std::move(raw));
}

ParsedSimpleTypeIdentifierSyntax
ParsedSyntaxRecorder::makeSimpleTypeIdentifier(ParsedTokenSyntax Name, Optional<ParsedGenericArgumentClauseSyntax> GenericArgumentClause,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSimpleTypeIdentifier(std::move(Name), std::move(GenericArgumentClause), SPCtx);
  return recordSimpleTypeIdentifier(std::move(Name), std::move(GenericArgumentClause), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedMemberTypeIdentifierSyntax
ParsedSyntaxRecorder::recordMemberTypeIdentifier(ParsedTypeSyntax BaseType, ParsedTokenSyntax Period, ParsedTokenSyntax Name, Optional<ParsedGenericArgumentClauseSyntax> GenericArgumentClause,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::MemberTypeIdentifier, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BaseType.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Period.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericArgumentClause.hasValue() ? GenericArgumentClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedMemberTypeIdentifierSyntax(std::move(raw));
}

ParsedMemberTypeIdentifierSyntax
ParsedSyntaxRecorder::deferMemberTypeIdentifier(ParsedTypeSyntax BaseType, ParsedTokenSyntax Period, ParsedTokenSyntax Name, Optional<ParsedGenericArgumentClauseSyntax> GenericArgumentClause, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::MemberTypeIdentifier, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BaseType.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Period.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    GenericArgumentClause.hasValue() ? GenericArgumentClause->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedMemberTypeIdentifierSyntax(std::move(raw));
}

ParsedMemberTypeIdentifierSyntax
ParsedSyntaxRecorder::makeMemberTypeIdentifier(ParsedTypeSyntax BaseType, ParsedTokenSyntax Period, ParsedTokenSyntax Name, Optional<ParsedGenericArgumentClauseSyntax> GenericArgumentClause,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferMemberTypeIdentifier(std::move(BaseType), std::move(Period), std::move(Name), std::move(GenericArgumentClause), SPCtx);
  return recordMemberTypeIdentifier(std::move(BaseType), std::move(Period), std::move(Name), std::move(GenericArgumentClause), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedClassRestrictionTypeSyntax
ParsedSyntaxRecorder::recordClassRestrictionType(ParsedTokenSyntax ClassKeyword,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ClassRestrictionType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ClassKeyword.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedClassRestrictionTypeSyntax(std::move(raw));
}

ParsedClassRestrictionTypeSyntax
ParsedSyntaxRecorder::deferClassRestrictionType(ParsedTokenSyntax ClassKeyword, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ClassRestrictionType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ClassKeyword.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedClassRestrictionTypeSyntax(std::move(raw));
}

ParsedClassRestrictionTypeSyntax
ParsedSyntaxRecorder::makeClassRestrictionType(ParsedTokenSyntax ClassKeyword,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferClassRestrictionType(std::move(ClassKeyword), SPCtx);
  return recordClassRestrictionType(std::move(ClassKeyword), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedArrayTypeSyntax
ParsedSyntaxRecorder::recordArrayType(ParsedTokenSyntax LeftSquareBracket, ParsedTypeSyntax ElementType, ParsedTokenSyntax RightSquareBracket,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ArrayType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquareBracket.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElementType.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquareBracket.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedArrayTypeSyntax(std::move(raw));
}

ParsedArrayTypeSyntax
ParsedSyntaxRecorder::deferArrayType(ParsedTokenSyntax LeftSquareBracket, ParsedTypeSyntax ElementType, ParsedTokenSyntax RightSquareBracket, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ArrayType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquareBracket.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ElementType.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquareBracket.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedArrayTypeSyntax(std::move(raw));
}

ParsedArrayTypeSyntax
ParsedSyntaxRecorder::makeArrayType(ParsedTokenSyntax LeftSquareBracket, ParsedTypeSyntax ElementType, ParsedTokenSyntax RightSquareBracket,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferArrayType(std::move(LeftSquareBracket), std::move(ElementType), std::move(RightSquareBracket), SPCtx);
  return recordArrayType(std::move(LeftSquareBracket), std::move(ElementType), std::move(RightSquareBracket), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedDictionaryTypeSyntax
ParsedSyntaxRecorder::recordDictionaryType(ParsedTokenSyntax LeftSquareBracket, ParsedTypeSyntax KeyType, ParsedTokenSyntax Colon, ParsedTypeSyntax ValueType, ParsedTokenSyntax RightSquareBracket,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::DictionaryType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquareBracket.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    KeyType.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ValueType.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquareBracket.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedDictionaryTypeSyntax(std::move(raw));
}

ParsedDictionaryTypeSyntax
ParsedSyntaxRecorder::deferDictionaryType(ParsedTokenSyntax LeftSquareBracket, ParsedTypeSyntax KeyType, ParsedTokenSyntax Colon, ParsedTypeSyntax ValueType, ParsedTokenSyntax RightSquareBracket, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::DictionaryType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftSquareBracket.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    KeyType.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ValueType.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightSquareBracket.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedDictionaryTypeSyntax(std::move(raw));
}

ParsedDictionaryTypeSyntax
ParsedSyntaxRecorder::makeDictionaryType(ParsedTokenSyntax LeftSquareBracket, ParsedTypeSyntax KeyType, ParsedTokenSyntax Colon, ParsedTypeSyntax ValueType, ParsedTokenSyntax RightSquareBracket,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferDictionaryType(std::move(LeftSquareBracket), std::move(KeyType), std::move(Colon), std::move(ValueType), std::move(RightSquareBracket), SPCtx);
  return recordDictionaryType(std::move(LeftSquareBracket), std::move(KeyType), std::move(Colon), std::move(ValueType), std::move(RightSquareBracket), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedMetatypeTypeSyntax
ParsedSyntaxRecorder::recordMetatypeType(ParsedTypeSyntax BaseType, ParsedTokenSyntax Period, ParsedTokenSyntax TypeOrProtocol,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::MetatypeType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BaseType.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Period.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeOrProtocol.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedMetatypeTypeSyntax(std::move(raw));
}

ParsedMetatypeTypeSyntax
ParsedSyntaxRecorder::deferMetatypeType(ParsedTypeSyntax BaseType, ParsedTokenSyntax Period, ParsedTokenSyntax TypeOrProtocol, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::MetatypeType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BaseType.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Period.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeOrProtocol.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedMetatypeTypeSyntax(std::move(raw));
}

ParsedMetatypeTypeSyntax
ParsedSyntaxRecorder::makeMetatypeType(ParsedTypeSyntax BaseType, ParsedTokenSyntax Period, ParsedTokenSyntax TypeOrProtocol,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferMetatypeType(std::move(BaseType), std::move(Period), std::move(TypeOrProtocol), SPCtx);
  return recordMetatypeType(std::move(BaseType), std::move(Period), std::move(TypeOrProtocol), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedOptionalTypeSyntax
ParsedSyntaxRecorder::recordOptionalType(ParsedTypeSyntax WrappedType, ParsedTokenSyntax QuestionMark,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::OptionalType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WrappedType.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionMark.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedOptionalTypeSyntax(std::move(raw));
}

ParsedOptionalTypeSyntax
ParsedSyntaxRecorder::deferOptionalType(ParsedTypeSyntax WrappedType, ParsedTokenSyntax QuestionMark, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::OptionalType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WrappedType.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionMark.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedOptionalTypeSyntax(std::move(raw));
}

ParsedOptionalTypeSyntax
ParsedSyntaxRecorder::makeOptionalType(ParsedTypeSyntax WrappedType, ParsedTokenSyntax QuestionMark,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferOptionalType(std::move(WrappedType), std::move(QuestionMark), SPCtx);
  return recordOptionalType(std::move(WrappedType), std::move(QuestionMark), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedSomeTypeSyntax
ParsedSyntaxRecorder::recordSomeType(ParsedTokenSyntax SomeSpecifier, ParsedTypeSyntax BaseType,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::SomeType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SomeSpecifier.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BaseType.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedSomeTypeSyntax(std::move(raw));
}

ParsedSomeTypeSyntax
ParsedSyntaxRecorder::deferSomeType(ParsedTokenSyntax SomeSpecifier, ParsedTypeSyntax BaseType, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::SomeType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SomeSpecifier.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BaseType.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedSomeTypeSyntax(std::move(raw));
}

ParsedSomeTypeSyntax
ParsedSyntaxRecorder::makeSomeType(ParsedTokenSyntax SomeSpecifier, ParsedTypeSyntax BaseType,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferSomeType(std::move(SomeSpecifier), std::move(BaseType), SPCtx);
  return recordSomeType(std::move(SomeSpecifier), std::move(BaseType), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedImplicitlyUnwrappedOptionalTypeSyntax
ParsedSyntaxRecorder::recordImplicitlyUnwrappedOptionalType(ParsedTypeSyntax WrappedType, ParsedTokenSyntax ExclamationMark,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ImplicitlyUnwrappedOptionalType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WrappedType.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ExclamationMark.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedImplicitlyUnwrappedOptionalTypeSyntax(std::move(raw));
}

ParsedImplicitlyUnwrappedOptionalTypeSyntax
ParsedSyntaxRecorder::deferImplicitlyUnwrappedOptionalType(ParsedTypeSyntax WrappedType, ParsedTokenSyntax ExclamationMark, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ImplicitlyUnwrappedOptionalType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    WrappedType.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ExclamationMark.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedImplicitlyUnwrappedOptionalTypeSyntax(std::move(raw));
}

ParsedImplicitlyUnwrappedOptionalTypeSyntax
ParsedSyntaxRecorder::makeImplicitlyUnwrappedOptionalType(ParsedTypeSyntax WrappedType, ParsedTokenSyntax ExclamationMark,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferImplicitlyUnwrappedOptionalType(std::move(WrappedType), std::move(ExclamationMark), SPCtx);
  return recordImplicitlyUnwrappedOptionalType(std::move(WrappedType), std::move(ExclamationMark), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCompositionTypeElementSyntax
ParsedSyntaxRecorder::recordCompositionTypeElement(ParsedTypeSyntax Type, Optional<ParsedTokenSyntax> Ampersand,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::CompositionTypeElement, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Ampersand.hasValue() ? Ampersand->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedCompositionTypeElementSyntax(std::move(raw));
}

ParsedCompositionTypeElementSyntax
ParsedSyntaxRecorder::deferCompositionTypeElement(ParsedTypeSyntax Type, Optional<ParsedTokenSyntax> Ampersand, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CompositionTypeElement, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Ampersand.hasValue() ? Ampersand->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedCompositionTypeElementSyntax(std::move(raw));
}

ParsedCompositionTypeElementSyntax
ParsedSyntaxRecorder::makeCompositionTypeElement(ParsedTypeSyntax Type, Optional<ParsedTokenSyntax> Ampersand,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCompositionTypeElement(std::move(Type), std::move(Ampersand), SPCtx);
  return recordCompositionTypeElement(std::move(Type), std::move(Ampersand), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCompositionTypeElementListSyntax
ParsedSyntaxRecorder::recordCompositionTypeElementList(
    ArrayRef<ParsedCompositionTypeElementSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::CompositionTypeElementList, layout);
  return ParsedCompositionTypeElementListSyntax(std::move(raw));
}

ParsedCompositionTypeElementListSyntax
ParsedSyntaxRecorder::deferCompositionTypeElementList(
    ArrayRef<ParsedCompositionTypeElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CompositionTypeElementList,
                             layout, SPCtx);
  return ParsedCompositionTypeElementListSyntax(std::move(raw));
}

ParsedCompositionTypeElementListSyntax
ParsedSyntaxRecorder::makeCompositionTypeElementList(
    ArrayRef<ParsedCompositionTypeElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCompositionTypeElementList(elements, SPCtx);
  return recordCompositionTypeElementList(elements, SPCtx.getRecorder());
}

ParsedCompositionTypeElementListSyntax
ParsedSyntaxRecorder::makeBlankCompositionTypeElementList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CompositionTypeElementList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::CompositionTypeElementList, loc);
  }
  return ParsedCompositionTypeElementListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedCompositionTypeSyntax
ParsedSyntaxRecorder::recordCompositionType(ParsedCompositionTypeElementListSyntax Elements,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::CompositionType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedCompositionTypeSyntax(std::move(raw));
}

ParsedCompositionTypeSyntax
ParsedSyntaxRecorder::deferCompositionType(ParsedCompositionTypeElementListSyntax Elements, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::CompositionType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedCompositionTypeSyntax(std::move(raw));
}

ParsedCompositionTypeSyntax
ParsedSyntaxRecorder::makeCompositionType(ParsedCompositionTypeElementListSyntax Elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferCompositionType(std::move(Elements), SPCtx);
  return recordCompositionType(std::move(Elements), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTupleTypeElementSyntax
ParsedSyntaxRecorder::recordTupleTypeElement(Optional<ParsedTokenSyntax> InOut, Optional<ParsedTokenSyntax> Name, Optional<ParsedTokenSyntax> SecondName, Optional<ParsedTokenSyntax> Colon, ParsedTypeSyntax Type, Optional<ParsedTokenSyntax> Ellipsis, Optional<ParsedInitializerClauseSyntax> Initializer, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TupleTypeElement, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InOut.hasValue() ? InOut->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.hasValue() ? Name->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SecondName.hasValue() ? SecondName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Ellipsis.hasValue() ? Ellipsis->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.hasValue() ? Initializer->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTupleTypeElementSyntax(std::move(raw));
}

ParsedTupleTypeElementSyntax
ParsedSyntaxRecorder::deferTupleTypeElement(Optional<ParsedTokenSyntax> InOut, Optional<ParsedTokenSyntax> Name, Optional<ParsedTokenSyntax> SecondName, Optional<ParsedTokenSyntax> Colon, ParsedTypeSyntax Type, Optional<ParsedTokenSyntax> Ellipsis, Optional<ParsedInitializerClauseSyntax> Initializer, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TupleTypeElement, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    InOut.hasValue() ? InOut->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Name.hasValue() ? Name->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SecondName.hasValue() ? SecondName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.hasValue() ? Colon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Ellipsis.hasValue() ? Ellipsis->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Initializer.hasValue() ? Initializer->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTupleTypeElementSyntax(std::move(raw));
}

ParsedTupleTypeElementSyntax
ParsedSyntaxRecorder::makeTupleTypeElement(Optional<ParsedTokenSyntax> InOut, Optional<ParsedTokenSyntax> Name, Optional<ParsedTokenSyntax> SecondName, Optional<ParsedTokenSyntax> Colon, ParsedTypeSyntax Type, Optional<ParsedTokenSyntax> Ellipsis, Optional<ParsedInitializerClauseSyntax> Initializer, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTupleTypeElement(std::move(InOut), std::move(Name), std::move(SecondName), std::move(Colon), std::move(Type), std::move(Ellipsis), std::move(Initializer), std::move(TrailingComma), SPCtx);
  return recordTupleTypeElement(std::move(InOut), std::move(Name), std::move(SecondName), std::move(Colon), std::move(Type), std::move(Ellipsis), std::move(Initializer), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTupleTypeElementListSyntax
ParsedSyntaxRecorder::recordTupleTypeElementList(
    ArrayRef<ParsedTupleTypeElementSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::TupleTypeElementList, layout);
  return ParsedTupleTypeElementListSyntax(std::move(raw));
}

ParsedTupleTypeElementListSyntax
ParsedSyntaxRecorder::deferTupleTypeElementList(
    ArrayRef<ParsedTupleTypeElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TupleTypeElementList,
                             layout, SPCtx);
  return ParsedTupleTypeElementListSyntax(std::move(raw));
}

ParsedTupleTypeElementListSyntax
ParsedSyntaxRecorder::makeTupleTypeElementList(
    ArrayRef<ParsedTupleTypeElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTupleTypeElementList(elements, SPCtx);
  return recordTupleTypeElementList(elements, SPCtx.getRecorder());
}

ParsedTupleTypeElementListSyntax
ParsedSyntaxRecorder::makeBlankTupleTypeElementList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TupleTypeElementList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::TupleTypeElementList, loc);
  }
  return ParsedTupleTypeElementListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTupleTypeSyntax
ParsedSyntaxRecorder::recordTupleType(ParsedTokenSyntax LeftParen, ParsedTupleTypeElementListSyntax Elements, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TupleType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTupleTypeSyntax(std::move(raw));
}

ParsedTupleTypeSyntax
ParsedSyntaxRecorder::deferTupleType(ParsedTokenSyntax LeftParen, ParsedTupleTypeElementListSyntax Elements, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TupleType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTupleTypeSyntax(std::move(raw));
}

ParsedTupleTypeSyntax
ParsedSyntaxRecorder::makeTupleType(ParsedTokenSyntax LeftParen, ParsedTupleTypeElementListSyntax Elements, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTupleType(std::move(LeftParen), std::move(Elements), std::move(RightParen), SPCtx);
  return recordTupleType(std::move(LeftParen), std::move(Elements), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedFunctionTypeSyntax
ParsedSyntaxRecorder::recordFunctionType(ParsedTokenSyntax LeftParen, ParsedTupleTypeElementListSyntax Arguments, ParsedTokenSyntax RightParen, Optional<ParsedTokenSyntax> ThrowsOrRethrowsKeyword, ParsedTokenSyntax Arrow, ParsedTypeSyntax ReturnType,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::FunctionType, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arguments.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsOrRethrowsKeyword.hasValue() ? ThrowsOrRethrowsKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arrow.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ReturnType.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedFunctionTypeSyntax(std::move(raw));
}

ParsedFunctionTypeSyntax
ParsedSyntaxRecorder::deferFunctionType(ParsedTokenSyntax LeftParen, ParsedTupleTypeElementListSyntax Arguments, ParsedTokenSyntax RightParen, Optional<ParsedTokenSyntax> ThrowsOrRethrowsKeyword, ParsedTokenSyntax Arrow, ParsedTypeSyntax ReturnType, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::FunctionType, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arguments.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ThrowsOrRethrowsKeyword.hasValue() ? ThrowsOrRethrowsKeyword->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arrow.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ReturnType.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedFunctionTypeSyntax(std::move(raw));
}

ParsedFunctionTypeSyntax
ParsedSyntaxRecorder::makeFunctionType(ParsedTokenSyntax LeftParen, ParsedTupleTypeElementListSyntax Arguments, ParsedTokenSyntax RightParen, Optional<ParsedTokenSyntax> ThrowsOrRethrowsKeyword, ParsedTokenSyntax Arrow, ParsedTypeSyntax ReturnType,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferFunctionType(std::move(LeftParen), std::move(Arguments), std::move(RightParen), std::move(ThrowsOrRethrowsKeyword), std::move(Arrow), std::move(ReturnType), SPCtx);
  return recordFunctionType(std::move(LeftParen), std::move(Arguments), std::move(RightParen), std::move(ThrowsOrRethrowsKeyword), std::move(Arrow), std::move(ReturnType), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAttributedTypeSyntax
ParsedSyntaxRecorder::recordAttributedType(Optional<ParsedTokenSyntax> Specifier, Optional<ParsedAttributeListSyntax> Attributes, ParsedTypeSyntax BaseType,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AttributedType, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Specifier.hasValue() ? Specifier->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BaseType.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAttributedTypeSyntax(std::move(raw));
}

ParsedAttributedTypeSyntax
ParsedSyntaxRecorder::deferAttributedType(Optional<ParsedTokenSyntax> Specifier, Optional<ParsedAttributeListSyntax> Attributes, ParsedTypeSyntax BaseType, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AttributedType, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Specifier.hasValue() ? Specifier->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Attributes.hasValue() ? Attributes->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    BaseType.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAttributedTypeSyntax(std::move(raw));
}

ParsedAttributedTypeSyntax
ParsedSyntaxRecorder::makeAttributedType(Optional<ParsedTokenSyntax> Specifier, Optional<ParsedAttributeListSyntax> Attributes, ParsedTypeSyntax BaseType,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAttributedType(std::move(Specifier), std::move(Attributes), std::move(BaseType), SPCtx);
  return recordAttributedType(std::move(Specifier), std::move(Attributes), std::move(BaseType), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedGenericArgumentListSyntax
ParsedSyntaxRecorder::recordGenericArgumentList(
    ArrayRef<ParsedGenericArgumentSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::GenericArgumentList, layout);
  return ParsedGenericArgumentListSyntax(std::move(raw));
}

ParsedGenericArgumentListSyntax
ParsedSyntaxRecorder::deferGenericArgumentList(
    ArrayRef<ParsedGenericArgumentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericArgumentList,
                             layout, SPCtx);
  return ParsedGenericArgumentListSyntax(std::move(raw));
}

ParsedGenericArgumentListSyntax
ParsedSyntaxRecorder::makeGenericArgumentList(
    ArrayRef<ParsedGenericArgumentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferGenericArgumentList(elements, SPCtx);
  return recordGenericArgumentList(elements, SPCtx.getRecorder());
}

ParsedGenericArgumentListSyntax
ParsedSyntaxRecorder::makeBlankGenericArgumentList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericArgumentList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::GenericArgumentList, loc);
  }
  return ParsedGenericArgumentListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedGenericArgumentSyntax
ParsedSyntaxRecorder::recordGenericArgument(ParsedTypeSyntax ArgumentType, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::GenericArgument, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArgumentType.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedGenericArgumentSyntax(std::move(raw));
}

ParsedGenericArgumentSyntax
ParsedSyntaxRecorder::deferGenericArgument(ParsedTypeSyntax ArgumentType, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericArgument, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ArgumentType.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedGenericArgumentSyntax(std::move(raw));
}

ParsedGenericArgumentSyntax
ParsedSyntaxRecorder::makeGenericArgument(ParsedTypeSyntax ArgumentType, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferGenericArgument(std::move(ArgumentType), std::move(TrailingComma), SPCtx);
  return recordGenericArgument(std::move(ArgumentType), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedGenericArgumentClauseSyntax
ParsedSyntaxRecorder::recordGenericArgumentClause(ParsedTokenSyntax LeftAngleBracket, ParsedGenericArgumentListSyntax Arguments, ParsedTokenSyntax RightAngleBracket,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::GenericArgumentClause, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftAngleBracket.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arguments.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightAngleBracket.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedGenericArgumentClauseSyntax(std::move(raw));
}

ParsedGenericArgumentClauseSyntax
ParsedSyntaxRecorder::deferGenericArgumentClause(ParsedTokenSyntax LeftAngleBracket, ParsedGenericArgumentListSyntax Arguments, ParsedTokenSyntax RightAngleBracket, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::GenericArgumentClause, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftAngleBracket.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Arguments.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightAngleBracket.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedGenericArgumentClauseSyntax(std::move(raw));
}

ParsedGenericArgumentClauseSyntax
ParsedSyntaxRecorder::makeGenericArgumentClause(ParsedTokenSyntax LeftAngleBracket, ParsedGenericArgumentListSyntax Arguments, ParsedTokenSyntax RightAngleBracket,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferGenericArgumentClause(std::move(LeftAngleBracket), std::move(Arguments), std::move(RightAngleBracket), SPCtx);
  return recordGenericArgumentClause(std::move(LeftAngleBracket), std::move(Arguments), std::move(RightAngleBracket), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTypeAnnotationSyntax
ParsedSyntaxRecorder::recordTypeAnnotation(ParsedTokenSyntax Colon, ParsedTypeSyntax Type,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TypeAnnotation, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTypeAnnotationSyntax(std::move(raw));
}

ParsedTypeAnnotationSyntax
ParsedSyntaxRecorder::deferTypeAnnotation(ParsedTokenSyntax Colon, ParsedTypeSyntax Type, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TypeAnnotation, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTypeAnnotationSyntax(std::move(raw));
}

ParsedTypeAnnotationSyntax
ParsedSyntaxRecorder::makeTypeAnnotation(ParsedTokenSyntax Colon, ParsedTypeSyntax Type,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTypeAnnotation(std::move(Colon), std::move(Type), SPCtx);
  return recordTypeAnnotation(std::move(Colon), std::move(Type), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedEnumCasePatternSyntax
ParsedSyntaxRecorder::recordEnumCasePattern(Optional<ParsedTypeSyntax> Type, ParsedTokenSyntax Period, ParsedTokenSyntax CaseName, Optional<ParsedTuplePatternSyntax> AssociatedTuple,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::EnumCasePattern, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.hasValue() ? Type->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Period.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseName.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssociatedTuple.hasValue() ? AssociatedTuple->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedEnumCasePatternSyntax(std::move(raw));
}

ParsedEnumCasePatternSyntax
ParsedSyntaxRecorder::deferEnumCasePattern(Optional<ParsedTypeSyntax> Type, ParsedTokenSyntax Period, ParsedTokenSyntax CaseName, Optional<ParsedTuplePatternSyntax> AssociatedTuple, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::EnumCasePattern, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.hasValue() ? Type->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Period.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    CaseName.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AssociatedTuple.hasValue() ? AssociatedTuple->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedEnumCasePatternSyntax(std::move(raw));
}

ParsedEnumCasePatternSyntax
ParsedSyntaxRecorder::makeEnumCasePattern(Optional<ParsedTypeSyntax> Type, ParsedTokenSyntax Period, ParsedTokenSyntax CaseName, Optional<ParsedTuplePatternSyntax> AssociatedTuple,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferEnumCasePattern(std::move(Type), std::move(Period), std::move(CaseName), std::move(AssociatedTuple), SPCtx);
  return recordEnumCasePattern(std::move(Type), std::move(Period), std::move(CaseName), std::move(AssociatedTuple), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIsTypePatternSyntax
ParsedSyntaxRecorder::recordIsTypePattern(ParsedTokenSyntax IsKeyword, ParsedTypeSyntax Type,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::IsTypePattern, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    IsKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedIsTypePatternSyntax(std::move(raw));
}

ParsedIsTypePatternSyntax
ParsedSyntaxRecorder::deferIsTypePattern(ParsedTokenSyntax IsKeyword, ParsedTypeSyntax Type, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IsTypePattern, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    IsKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedIsTypePatternSyntax(std::move(raw));
}

ParsedIsTypePatternSyntax
ParsedSyntaxRecorder::makeIsTypePattern(ParsedTokenSyntax IsKeyword, ParsedTypeSyntax Type,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIsTypePattern(std::move(IsKeyword), std::move(Type), SPCtx);
  return recordIsTypePattern(std::move(IsKeyword), std::move(Type), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedOptionalPatternSyntax
ParsedSyntaxRecorder::recordOptionalPattern(ParsedPatternSyntax SubPattern, ParsedTokenSyntax QuestionMark,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::OptionalPattern, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SubPattern.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionMark.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedOptionalPatternSyntax(std::move(raw));
}

ParsedOptionalPatternSyntax
ParsedSyntaxRecorder::deferOptionalPattern(ParsedPatternSyntax SubPattern, ParsedTokenSyntax QuestionMark, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::OptionalPattern, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    SubPattern.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    QuestionMark.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedOptionalPatternSyntax(std::move(raw));
}

ParsedOptionalPatternSyntax
ParsedSyntaxRecorder::makeOptionalPattern(ParsedPatternSyntax SubPattern, ParsedTokenSyntax QuestionMark,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferOptionalPattern(std::move(SubPattern), std::move(QuestionMark), SPCtx);
  return recordOptionalPattern(std::move(SubPattern), std::move(QuestionMark), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedIdentifierPatternSyntax
ParsedSyntaxRecorder::recordIdentifierPattern(ParsedTokenSyntax Identifier,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::IdentifierPattern, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedIdentifierPatternSyntax(std::move(raw));
}

ParsedIdentifierPatternSyntax
ParsedSyntaxRecorder::deferIdentifierPattern(ParsedTokenSyntax Identifier, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::IdentifierPattern, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Identifier.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedIdentifierPatternSyntax(std::move(raw));
}

ParsedIdentifierPatternSyntax
ParsedSyntaxRecorder::makeIdentifierPattern(ParsedTokenSyntax Identifier,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferIdentifierPattern(std::move(Identifier), SPCtx);
  return recordIdentifierPattern(std::move(Identifier), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAsTypePatternSyntax
ParsedSyntaxRecorder::recordAsTypePattern(ParsedPatternSyntax Pattern, ParsedTokenSyntax AsKeyword, ParsedTypeSyntax Type,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AsTypePattern, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AsKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAsTypePatternSyntax(std::move(raw));
}

ParsedAsTypePatternSyntax
ParsedSyntaxRecorder::deferAsTypePattern(ParsedPatternSyntax Pattern, ParsedTokenSyntax AsKeyword, ParsedTypeSyntax Type, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AsTypePattern, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    AsKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Type.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAsTypePatternSyntax(std::move(raw));
}

ParsedAsTypePatternSyntax
ParsedSyntaxRecorder::makeAsTypePattern(ParsedPatternSyntax Pattern, ParsedTokenSyntax AsKeyword, ParsedTypeSyntax Type,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAsTypePattern(std::move(Pattern), std::move(AsKeyword), std::move(Type), SPCtx);
  return recordAsTypePattern(std::move(Pattern), std::move(AsKeyword), std::move(Type), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTuplePatternSyntax
ParsedSyntaxRecorder::recordTuplePattern(ParsedTokenSyntax LeftParen, ParsedTuplePatternElementListSyntax Elements, ParsedTokenSyntax RightParen,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TuplePattern, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTuplePatternSyntax(std::move(raw));
}

ParsedTuplePatternSyntax
ParsedSyntaxRecorder::deferTuplePattern(ParsedTokenSyntax LeftParen, ParsedTuplePatternElementListSyntax Elements, ParsedTokenSyntax RightParen, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TuplePattern, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LeftParen.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Elements.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    RightParen.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTuplePatternSyntax(std::move(raw));
}

ParsedTuplePatternSyntax
ParsedSyntaxRecorder::makeTuplePattern(ParsedTokenSyntax LeftParen, ParsedTuplePatternElementListSyntax Elements, ParsedTokenSyntax RightParen,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTuplePattern(std::move(LeftParen), std::move(Elements), std::move(RightParen), SPCtx);
  return recordTuplePattern(std::move(LeftParen), std::move(Elements), std::move(RightParen), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedWildcardPatternSyntax
ParsedSyntaxRecorder::recordWildcardPattern(ParsedTokenSyntax Wildcard, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::WildcardPattern, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Wildcard.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedWildcardPatternSyntax(std::move(raw));
}

ParsedWildcardPatternSyntax
ParsedSyntaxRecorder::deferWildcardPattern(ParsedTokenSyntax Wildcard, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::WildcardPattern, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Wildcard.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TypeAnnotation.hasValue() ? TypeAnnotation->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedWildcardPatternSyntax(std::move(raw));
}

ParsedWildcardPatternSyntax
ParsedSyntaxRecorder::makeWildcardPattern(ParsedTokenSyntax Wildcard, Optional<ParsedTypeAnnotationSyntax> TypeAnnotation,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferWildcardPattern(std::move(Wildcard), std::move(TypeAnnotation), SPCtx);
  return recordWildcardPattern(std::move(Wildcard), std::move(TypeAnnotation), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTuplePatternElementSyntax
ParsedSyntaxRecorder::recordTuplePatternElement(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedPatternSyntax Pattern, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::TuplePatternElement, {
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedTuplePatternElementSyntax(std::move(raw));
}

ParsedTuplePatternElementSyntax
ParsedSyntaxRecorder::deferTuplePatternElement(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedPatternSyntax Pattern, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TuplePatternElement, {
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelName.hasValue() ? LabelName->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LabelColon.hasValue() ? LabelColon->getRaw() : ParsedRawSyntaxNode::null(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Pattern.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedTuplePatternElementSyntax(std::move(raw));
}

ParsedTuplePatternElementSyntax
ParsedSyntaxRecorder::makeTuplePatternElement(Optional<ParsedTokenSyntax> LabelName, Optional<ParsedTokenSyntax> LabelColon, ParsedPatternSyntax Pattern, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTuplePatternElement(std::move(LabelName), std::move(LabelColon), std::move(Pattern), std::move(TrailingComma), SPCtx);
  return recordTuplePatternElement(std::move(LabelName), std::move(LabelColon), std::move(Pattern), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedExpressionPatternSyntax
ParsedSyntaxRecorder::recordExpressionPattern(ParsedExprSyntax Expression,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ExpressionPattern, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedExpressionPatternSyntax(std::move(raw));
}

ParsedExpressionPatternSyntax
ParsedSyntaxRecorder::deferExpressionPattern(ParsedExprSyntax Expression, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ExpressionPattern, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Expression.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedExpressionPatternSyntax(std::move(raw));
}

ParsedExpressionPatternSyntax
ParsedSyntaxRecorder::makeExpressionPattern(ParsedExprSyntax Expression,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferExpressionPattern(std::move(Expression), SPCtx);
  return recordExpressionPattern(std::move(Expression), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedTuplePatternElementListSyntax
ParsedSyntaxRecorder::recordTuplePatternElementList(
    ArrayRef<ParsedTuplePatternElementSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::TuplePatternElementList, layout);
  return ParsedTuplePatternElementListSyntax(std::move(raw));
}

ParsedTuplePatternElementListSyntax
ParsedSyntaxRecorder::deferTuplePatternElementList(
    ArrayRef<ParsedTuplePatternElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TuplePatternElementList,
                             layout, SPCtx);
  return ParsedTuplePatternElementListSyntax(std::move(raw));
}

ParsedTuplePatternElementListSyntax
ParsedSyntaxRecorder::makeTuplePatternElementList(
    ArrayRef<ParsedTuplePatternElementSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferTuplePatternElementList(elements, SPCtx);
  return recordTuplePatternElementList(elements, SPCtx.getRecorder());
}

ParsedTuplePatternElementListSyntax
ParsedSyntaxRecorder::makeBlankTuplePatternElementList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::TuplePatternElementList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::TuplePatternElementList, loc);
  }
  return ParsedTuplePatternElementListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedValueBindingPatternSyntax
ParsedSyntaxRecorder::recordValueBindingPattern(ParsedTokenSyntax LetOrVarKeyword, ParsedPatternSyntax ValuePattern,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::ValueBindingPattern, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LetOrVarKeyword.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ValuePattern.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedValueBindingPatternSyntax(std::move(raw));
}

ParsedValueBindingPatternSyntax
ParsedSyntaxRecorder::deferValueBindingPattern(ParsedTokenSyntax LetOrVarKeyword, ParsedPatternSyntax ValuePattern, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::ValueBindingPattern, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    LetOrVarKeyword.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    ValuePattern.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedValueBindingPatternSyntax(std::move(raw));
}

ParsedValueBindingPatternSyntax
ParsedSyntaxRecorder::makeValueBindingPattern(ParsedTokenSyntax LetOrVarKeyword, ParsedPatternSyntax ValuePattern,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferValueBindingPattern(std::move(LetOrVarKeyword), std::move(ValuePattern), SPCtx);
  return recordValueBindingPattern(std::move(LetOrVarKeyword), std::move(ValuePattern), SPCtx.getRecorder());
}

#line 123 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAvailabilitySpecListSyntax
ParsedSyntaxRecorder::recordAvailabilitySpecList(
    ArrayRef<ParsedAvailabilityArgumentSyntax> elements,
    ParsedRawSyntaxRecorder &rec) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = rec.recordRawSyntax(SyntaxKind::AvailabilitySpecList, layout);
  return ParsedAvailabilitySpecListSyntax(std::move(raw));
}

ParsedAvailabilitySpecListSyntax
ParsedSyntaxRecorder::deferAvailabilitySpecList(
    ArrayRef<ParsedAvailabilityArgumentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  SmallVector<ParsedRawSyntaxNode, 16> layout;
  layout.reserve(elements.size());
  for (auto &element : elements) {
    layout.push_back(element.getRaw());
  }
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AvailabilitySpecList,
                             layout, SPCtx);
  return ParsedAvailabilitySpecListSyntax(std::move(raw));
}

ParsedAvailabilitySpecListSyntax
ParsedSyntaxRecorder::makeAvailabilitySpecList(
    ArrayRef<ParsedAvailabilityArgumentSyntax> elements,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAvailabilitySpecList(elements, SPCtx);
  return recordAvailabilitySpecList(elements, SPCtx.getRecorder());
}

ParsedAvailabilitySpecListSyntax
ParsedSyntaxRecorder::makeBlankAvailabilitySpecList(SourceLoc loc,
        SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    // FIXME: 'loc' is not preserved when capturing a deferred layout.
    raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AvailabilitySpecList, {}, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordEmptyRawSyntaxCollection(SyntaxKind::AvailabilitySpecList, loc);
  }
  return ParsedAvailabilitySpecListSyntax(std::move(raw));
}
#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAvailabilityArgumentSyntax
ParsedSyntaxRecorder::recordAvailabilityArgument(ParsedSyntax Entry, Optional<ParsedTokenSyntax> TrailingComma,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AvailabilityArgument, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Entry.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAvailabilityArgumentSyntax(std::move(raw));
}

ParsedAvailabilityArgumentSyntax
ParsedSyntaxRecorder::deferAvailabilityArgument(ParsedSyntax Entry, Optional<ParsedTokenSyntax> TrailingComma, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AvailabilityArgument, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Entry.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    TrailingComma.hasValue() ? TrailingComma->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAvailabilityArgumentSyntax(std::move(raw));
}

ParsedAvailabilityArgumentSyntax
ParsedSyntaxRecorder::makeAvailabilityArgument(ParsedSyntax Entry, Optional<ParsedTokenSyntax> TrailingComma,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAvailabilityArgument(std::move(Entry), std::move(TrailingComma), SPCtx);
  return recordAvailabilityArgument(std::move(Entry), std::move(TrailingComma), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAvailabilityLabeledArgumentSyntax
ParsedSyntaxRecorder::recordAvailabilityLabeledArgument(ParsedTokenSyntax Label, ParsedTokenSyntax Colon, ParsedSyntax Value,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AvailabilityLabeledArgument, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAvailabilityLabeledArgumentSyntax(std::move(raw));
}

ParsedAvailabilityLabeledArgumentSyntax
ParsedSyntaxRecorder::deferAvailabilityLabeledArgument(ParsedTokenSyntax Label, ParsedTokenSyntax Colon, ParsedSyntax Value, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AvailabilityLabeledArgument, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Label.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Colon.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Value.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAvailabilityLabeledArgumentSyntax(std::move(raw));
}

ParsedAvailabilityLabeledArgumentSyntax
ParsedSyntaxRecorder::makeAvailabilityLabeledArgument(ParsedTokenSyntax Label, ParsedTokenSyntax Colon, ParsedSyntax Value,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAvailabilityLabeledArgument(std::move(Label), std::move(Colon), std::move(Value), SPCtx);
  return recordAvailabilityLabeledArgument(std::move(Label), std::move(Colon), std::move(Value), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedAvailabilityVersionRestrictionSyntax
ParsedSyntaxRecorder::recordAvailabilityVersionRestriction(ParsedTokenSyntax Platform, ParsedVersionTupleSyntax Version,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::AvailabilityVersionRestriction, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Platform.getRaw(),
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Version.getRaw(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedAvailabilityVersionRestrictionSyntax(std::move(raw));
}

ParsedAvailabilityVersionRestrictionSyntax
ParsedSyntaxRecorder::deferAvailabilityVersionRestriction(ParsedTokenSyntax Platform, ParsedVersionTupleSyntax Version, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::AvailabilityVersionRestriction, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Platform.getRaw(),
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    Version.getRaw(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedAvailabilityVersionRestrictionSyntax(std::move(raw));
}

ParsedAvailabilityVersionRestrictionSyntax
ParsedSyntaxRecorder::makeAvailabilityVersionRestriction(ParsedTokenSyntax Platform, ParsedVersionTupleSyntax Version,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferAvailabilityVersionRestriction(std::move(Platform), std::move(Version), SPCtx);
  return recordAvailabilityVersionRestriction(std::move(Platform), std::move(Version), SPCtx.getRecorder());
}

#line 85 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
ParsedVersionTupleSyntax
ParsedSyntaxRecorder::recordVersionTuple(ParsedSyntax MajorMinor, Optional<ParsedTokenSyntax> PatchPeriod, Optional<ParsedTokenSyntax> PatchVersion,
                                       ParsedRawSyntaxRecorder &rec) {
  auto raw = rec.recordRawSyntax(SyntaxKind::VersionTuple, {
#line 93 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    MajorMinor.getRaw(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PatchPeriod.hasValue() ? PatchPeriod->getRaw() : ParsedRawSyntaxNode::null(),
#line 91 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PatchVersion.hasValue() ? PatchVersion->getRaw() : ParsedRawSyntaxNode::null(),
#line 96 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  });
  return ParsedVersionTupleSyntax(std::move(raw));
}

ParsedVersionTupleSyntax
ParsedSyntaxRecorder::deferVersionTuple(ParsedSyntax MajorMinor, Optional<ParsedTokenSyntax> PatchPeriod, Optional<ParsedTokenSyntax> PatchVersion, SyntaxParsingContext &SPCtx) {
  auto raw = ParsedRawSyntaxNode::makeDeferred(SyntaxKind::VersionTuple, {
#line 107 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    MajorMinor.getRaw(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PatchPeriod.hasValue() ? PatchPeriod->getRaw() : ParsedRawSyntaxNode::null(),
#line 105 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
    PatchVersion.hasValue() ? PatchVersion->getRaw() : ParsedRawSyntaxNode::null(),
#line 110 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"
  }, SPCtx);
  return ParsedVersionTupleSyntax(std::move(raw));
}

ParsedVersionTupleSyntax
ParsedSyntaxRecorder::makeVersionTuple(ParsedSyntax MajorMinor, Optional<ParsedTokenSyntax> PatchPeriod, Optional<ParsedTokenSyntax> PatchVersion,
    SyntaxParsingContext &SPCtx) {
  if (SPCtx.isBacktracking())
    return deferVersionTuple(std::move(MajorMinor), std::move(PatchPeriod), std::move(PatchVersion), SPCtx);
  return recordVersionTuple(std::move(MajorMinor), std::move(PatchPeriod), std::move(PatchVersion), SPCtx.getRecorder());
}

#line 208 "/Users/zhuzhenhua/Documents/SwiftSourceCode/swift/lib/Parse/ParsedSyntaxRecorder.cpp.gyb"

ParsedTokenSyntax
ParsedSyntaxRecorder::makeToken(const Token &Tok,
                                const ParsedTrivia &LeadingTrivia,
                                const ParsedTrivia &TrailingTrivia,
                                SyntaxParsingContext &SPCtx) {
  ParsedRawSyntaxNode raw;
  if (SPCtx.isBacktracking()) {
    raw = ParsedRawSyntaxNode::makeDeferred(Tok, LeadingTrivia, TrailingTrivia, SPCtx);
  } else {
    raw = SPCtx.getRecorder().recordToken(Tok, LeadingTrivia, TrailingTrivia);
  }
  return ParsedTokenSyntax(std::move(raw));
}

ParsedTupleTypeElementSyntax
ParsedSyntaxRecorder::makeTupleTypeElement(ParsedTypeSyntax Type,
                                    llvm::Optional<ParsedTokenSyntax> TrailingComma,
                                    SyntaxParsingContext &SPCtx) {
  return makeTupleTypeElement(None, None, None, None, Type, None, None,
                              TrailingComma, SPCtx);
}
